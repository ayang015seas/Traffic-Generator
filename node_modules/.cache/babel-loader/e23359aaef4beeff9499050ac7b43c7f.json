{"ast":null,"code":"'use strict';\n\nvar events = require('events');\n\nvar util = require('util');\n\nvar net = require('net');\n\nvar tls = require('tls');\n\nvar fs = require('fs');\n\nvar _ = require('lodash');\n\nvar methods = require('./definitions').methods;\n\nvar Channel = require('./channel');\n\nvar debug = require('./debug');\n\nvar Exchange = module.exports = function Exchange(connection, channel, name, options, openCallback) {\n  Channel.call(this, connection, channel);\n  this.name = name;\n  this.binds = 0; // keep track of queues bound\n\n  this.exchangeBinds = 0; // keep track of exchanges bound\n\n  this.sourceExchanges = {};\n  this.options = _.defaults(options || {}, {\n    autoDelete: true\n  });\n  this._openCallback = openCallback;\n  this._sequence = null;\n  this._unAcked = {};\n  this._addedExchangeErrorHandler = false;\n};\n\nutil.inherits(Exchange, Channel); // creates an error handler scoped to the given `exchange`\n\nfunction createExchangeErrorHandlerFor(exchange) {\n  return function (err) {\n    if (!exchange.options.confirm) return; // should requeue instead?\n    // https://www.rabbitmq.com/reliability.html#producer\n\n    debug && debug('Exchange error handler triggered, erroring and wiping all unacked publishes');\n\n    for (var id in exchange._unAcked) {\n      var task = exchange._unAcked[id];\n      task.emit('ack error', err);\n      delete exchange._unAcked[id];\n    }\n  };\n}\n\nExchange.prototype._onMethod = function (channel, method, args) {\n  this.emit(method.name, args);\n  if (this._handleTaskReply.apply(this, arguments)) return true;\n  var cb;\n\n  switch (method) {\n    case methods.channelOpenOk:\n      this._sequence = null;\n\n      if (!this._addedExchangeErrorHandler) {\n        var errorHandler = createExchangeErrorHandlerFor(this);\n        this.connection.on('error', errorHandler);\n        this.on('error', errorHandler);\n        this._addedExchangeErrorHandler = true;\n      } // Pre-baked exchanges don't need to be declared\n\n\n      if (/^$|(amq\\.)/.test(this.name)) {\n        //If confirm mode is specified we have to set it no matter the exchange.\n        if (this.options.confirm) {\n          this._confirmSelect(channel);\n\n          return;\n        }\n\n        this.state = 'open'; // - issue #33 fix\n\n        if (this._openCallback) {\n          this._openCallback(this);\n\n          this._openCallback = null;\n        } // --\n\n\n        this.emit('open'); // For if we want to delete a exchange,\n        // we dont care if all of the options match.\n      } else if (this.options.noDeclare) {\n        if (this.options.confirm) {\n          this._confirmSelect(channel);\n\n          return;\n        }\n\n        this.state = 'open';\n\n        if (this._openCallback) {\n          this._openCallback(this);\n\n          this._openCallback = null;\n        }\n\n        this.emit('open');\n      } else {\n        this.connection._sendMethod(channel, methods.exchangeDeclare, {\n          reserved1: 0,\n          reserved2: false,\n          reserved3: false,\n          exchange: this.name,\n          type: this.options.type || 'topic',\n          passive: !!this.options.passive,\n          durable: !!this.options.durable,\n          autoDelete: !!this.options.autoDelete,\n          internal: !!this.options.internal,\n          noWait: false,\n          \"arguments\": this.options.arguments || {}\n        });\n\n        this.state = 'declaring';\n      }\n\n      break;\n\n    case methods.exchangeDeclareOk:\n      if (this.options.confirm) {\n        this._confirmSelect(channel);\n      } else {\n        this.state = 'open';\n        this.emit('open');\n\n        if (this._openCallback) {\n          this._openCallback(this);\n\n          this._openCallback = null;\n        }\n      }\n\n      break;\n\n    case methods.confirmSelectOk:\n      this._sequence = 1;\n      this.state = 'open';\n      this.emit('open');\n\n      if (this._openCallback) {\n        this._openCallback(this);\n\n        this._openCallback = null;\n      }\n\n      break;\n\n    case methods.channelClose:\n      this.state = \"closed\";\n      this.closeOK();\n      this.connection.exchangeClosed(this.name);\n      var e = new Error(args.replyText);\n      e.code = args.replyCode;\n      this.emit('error', e);\n      this.emit('close');\n      break;\n\n    case methods.channelCloseOk:\n      this.connection.exchangeClosed(this.name);\n      this.emit('close');\n      break;\n\n    case methods.basicAck:\n      this.emit('basic-ack', args);\n      var sequenceNumber = args.deliveryTag.readUInt32BE(4),\n          tag;\n      debug && debug(\"basic-ack, sequence: \", sequenceNumber);\n\n      if (sequenceNumber === 0 && args.multiple === true) {\n        // we must ack everything\n        for (tag in this._unAcked) {\n          this._unAcked[tag].emit('ack');\n\n          delete this._unAcked[tag];\n        }\n      } else if (sequenceNumber !== 0 && args.multiple === true) {\n        // we must ack everything before the delivery tag\n        for (tag in this._unAcked) {\n          if (tag <= sequenceNumber) {\n            this._unAcked[tag].emit('ack');\n\n            delete this._unAcked[tag];\n          }\n        }\n      } else if (this._unAcked[sequenceNumber] && args.multiple === false) {\n        // simple single ack\n        this._unAcked[sequenceNumber].emit('ack');\n\n        delete this._unAcked[sequenceNumber];\n      }\n\n      break;\n\n    case methods.basicReturn:\n      this.emit('basic-return', args);\n      break;\n\n    case methods.exchangeBindOk:\n      if (this._bindCallback) {\n        // setting this._bindCallback to null before calling the callback allows for a subsequent bind within the callback\n        cb = this._bindCallback;\n        this._bindCallback = null;\n        cb(this);\n      }\n\n      break;\n\n    case methods.exchangeUnbindOk:\n      if (this._unbindCallback) {\n        cb = this._unbindCallback;\n        this._unbindCallback = null;\n        cb(this);\n      }\n\n      break;\n\n    default:\n      throw new Error(\"Uncaught method '\" + method.name + \"' with args \" + JSON.stringify(args));\n  }\n\n  this._tasksFlush();\n}; // exchange.publish('routing.key', 'body');\n//\n// the third argument can specify additional options\n// - mandatory (boolean, default false)\n// - immediate (boolean, default false)\n// - contentType (default 'application/octet-stream')\n// - contentEncoding\n// - headers\n// - deliveryMode\n// - priority (0-9)\n// - correlationId\n// - replyTo\n// - expiration\n// - messageId\n// - timestamp\n// - userId\n// - appId\n// - clusterId\n//\n// the callback is optional and is only used when confirm is turned on for the exchange\n\n\nExchange.prototype.publish = function (routingKey, data, options, callback) {\n  var self = this;\n\n  callback = callback || function () {};\n\n  if (this.connection._blocked) {\n    return callback(true, new Error('Connection is blocked, server reason: ' + this.connection._blockedReason));\n  }\n\n  if (this.state !== 'open') {\n    this._sequence = null;\n    return callback(true, new Error('Can not publish: exchange is not open'));\n  }\n\n  if (this.options.confirm && !this._readyToPublishWithConfirms()) {\n    return callback(true, new Error('Not yet ready to publish with confirms'));\n  }\n\n  options = _.assignIn({}, options || {});\n  options.routingKey = routingKey;\n  options.exchange = self.name;\n  options.mandatory = options.mandatory ? true : false;\n  options.immediate = options.immediate ? true : false;\n  options.reserved1 = 0;\n\n  var task = this._taskPush(null, function () {\n    self.connection._sendMethod(self.channel, methods.basicPublish, options); // This interface is probably not appropriate for streaming large files.\n    // (Of course it's arguable about whether AMQP is the appropriate\n    // transport for large files.) The content header wants to know the size\n    // of the data before sending it - so there's no point in trying to have a\n    // general streaming interface - streaming messages of unknown size simply\n    // isn't possible with AMQP. This is all to say, don't send big messages.\n    // If you need to stream something large, chunk it yourself.\n\n\n    self.connection._sendBody(self.channel, data, options);\n  });\n\n  if (self.options.confirm) self._awaitConfirm(task, callback);\n  return task;\n}; // registers tasks for confirms\n\n\nExchange.prototype._awaitConfirm = function _awaitConfirm(task, callback) {\n  if (!this._addedExchangeErrorHandler) {\n    // if connection fails, we want to ack error all unacked publishes.\n    this.connection.on('error', createExchangeErrorHandlerFor(this));\n    this.on('error', createExchangeErrorHandlerFor(this));\n    this._addedExchangeErrorHandler = true;\n  }\n\n  debug && debug('awaiting confirmation for ' + this._sequence);\n  task.sequence = this._sequence;\n  this._unAcked[this._sequence] = task;\n  this._sequence++;\n  if ('function' != typeof callback) return;\n  task.once('ack error', function (err) {\n    task.removeAllListeners();\n    callback(true, err);\n  });\n  task.once('ack', function () {\n    task.removeAllListeners();\n    callback(false);\n  });\n}; // do any necessary cleanups eg. after queue destruction\n\n\nExchange.prototype.cleanup = function () {\n  if (this.binds === 0) {\n    // don't keep reference open if unused\n    this.connection.exchangeClosed(this.name);\n  }\n};\n\nExchange.prototype.destroy = function (ifUnused) {\n  var self = this;\n  return this._taskPush(methods.exchangeDeleteOk, function () {\n    self.connection.exchangeClosed(self.name);\n\n    self.connection._sendMethod(self.channel, methods.exchangeDelete, {\n      reserved1: 0,\n      exchange: self.name,\n      ifUnused: ifUnused ? true : false,\n      noWait: false\n    });\n  });\n}; // E2E Unbind\n// support RabbitMQ's exchange-to-exchange binding extension\n// http://www.rabbitmq.com/e2e.html\n\n\nExchange.prototype.unbind = function ()\n/* exchange, routingKey [, bindCallback] */\n{\n  var self = this; // Both arguments are required. The binding to the destination\n  // exchange/routingKey will be unbound.\n\n  var exchange = arguments[0],\n      routingKey = arguments[1],\n      callback = arguments[2];\n  if (callback) this._unbindCallback = callback;\n  return this._taskPush(methods.exchangeUnbindOk, function () {\n    var source = exchange instanceof Exchange ? exchange.name : exchange;\n    var destination = self.name;\n\n    if (source in self.connection.exchanges) {\n      delete self.sourceExchanges[source];\n      self.connection.exchanges[source].exchangeBinds--;\n    }\n\n    self.connection._sendMethod(self.channel, methods.exchangeUnbind, {\n      reserved1: 0,\n      destination: destination,\n      source: source,\n      routingKey: routingKey,\n      noWait: false,\n      \"arguments\": {}\n    });\n  });\n}; // E2E Bind\n// support RabbitMQ's exchange-to-exchange binding extension\n// http://www.rabbitmq.com/e2e.html\n\n\nExchange.prototype.bind = function ()\n/* exchange, routingKey [, bindCallback] */\n{\n  var self = this; // Two arguments are required. The binding to the destination\n  // exchange/routingKey will be established.\n\n  var exchange = arguments[0],\n      routingKey = arguments[1],\n      callback = arguments[2];\n  if (callback) this._bindCallback = callback;\n  var source = exchange instanceof Exchange ? exchange.name : exchange;\n  var destination = self.name;\n\n  if (source in self.connection.exchanges) {\n    self.sourceExchanges[source] = self.connection.exchanges[source];\n    self.connection.exchanges[source].exchangeBinds++;\n  }\n\n  self.connection._sendMethod(self.channel, methods.exchangeBind, {\n    reserved1: 0,\n    destination: destination,\n    source: source,\n    routingKey: routingKey,\n    noWait: false,\n    \"arguments\": {}\n  });\n}; // E2E Bind\n// support RabbitMQ's exchange-to-exchange binding extension\n// http://www.rabbitmq.com/e2e.html\n\n\nExchange.prototype.bind_headers = function ()\n/* exchange, routing [, bindCallback] */\n{\n  var self = this; // Two arguments are required. The binding to the destination\n  // exchange/routingKey will be established.\n\n  var exchange = arguments[0],\n      routing = arguments[1],\n      callback = arguments[2];\n  if (callback) this._bindCallback = callback;\n  var source = exchange instanceof Exchange ? exchange.name : exchange;\n  var destination = self.name;\n\n  if (source in self.connection.exchanges) {\n    self.sourceExchanges[source] = self.connection.exchanges[source];\n    self.connection.exchanges[source].exchangeBinds++;\n  }\n\n  self.connection._sendMethod(self.channel, methods.exchangeBind, {\n    reserved1: 0,\n    destination: destination,\n    source: source,\n    routingKey: '',\n    noWait: false,\n    \"arguments\": routing\n  });\n};\n\nExchange.prototype._confirmSelect = function (channel) {\n  this.connection._sendMethod(channel, methods.confirmSelect, {\n    noWait: false\n  });\n};\n\nExchange.prototype._readyToPublishWithConfirms = function () {\n  return this._sequence != null;\n};","map":{"version":3,"sources":["/Users/alexyang/Desktop/todolist/Traffic-Generator/node_modules/amqp/lib/exchange.js"],"names":["events","require","util","net","tls","fs","_","methods","Channel","debug","Exchange","module","exports","connection","channel","name","options","openCallback","call","binds","exchangeBinds","sourceExchanges","defaults","autoDelete","_openCallback","_sequence","_unAcked","_addedExchangeErrorHandler","inherits","createExchangeErrorHandlerFor","exchange","err","confirm","id","task","emit","prototype","_onMethod","method","args","_handleTaskReply","apply","arguments","cb","channelOpenOk","errorHandler","on","test","_confirmSelect","state","noDeclare","_sendMethod","exchangeDeclare","reserved1","reserved2","reserved3","type","passive","durable","internal","noWait","exchangeDeclareOk","confirmSelectOk","channelClose","closeOK","exchangeClosed","e","Error","replyText","code","replyCode","channelCloseOk","basicAck","sequenceNumber","deliveryTag","readUInt32BE","tag","multiple","basicReturn","exchangeBindOk","_bindCallback","exchangeUnbindOk","_unbindCallback","JSON","stringify","_tasksFlush","publish","routingKey","data","callback","self","_blocked","_blockedReason","_readyToPublishWithConfirms","assignIn","mandatory","immediate","_taskPush","basicPublish","_sendBody","_awaitConfirm","sequence","once","removeAllListeners","cleanup","destroy","ifUnused","exchangeDeleteOk","exchangeDelete","unbind","source","destination","exchanges","exchangeUnbind","bind","exchangeBind","bind_headers","routing","confirmSelect"],"mappings":"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","sourcesContent":["'use strict';\nvar events = require('events');\nvar util = require('util');\nvar net = require('net');\nvar tls = require('tls');\nvar fs = require('fs');\nvar _ = require('lodash');\nvar methods = require('./definitions').methods;\nvar Channel = require('./channel');\nvar debug = require('./debug');\n\nvar Exchange = module.exports = function Exchange (connection, channel, name, options, openCallback) {\n  Channel.call(this, connection, channel);\n  this.name = name;\n  this.binds = 0; // keep track of queues bound\n  this.exchangeBinds = 0; // keep track of exchanges bound\n  this.sourceExchanges = {};\n  this.options = _.defaults(options || {}, {autoDelete: true});\n  this._openCallback = openCallback;\n\n  this._sequence = null;\n  this._unAcked  = {};\n  this._addedExchangeErrorHandler = false;\n};\nutil.inherits(Exchange, Channel);\n\n// creates an error handler scoped to the given `exchange`\nfunction createExchangeErrorHandlerFor (exchange) {\n  return function (err) {\n    if (!exchange.options.confirm) return;\n\n    // should requeue instead?\n    // https://www.rabbitmq.com/reliability.html#producer\n    debug && debug('Exchange error handler triggered, erroring and wiping all unacked publishes');\n    for (var id in exchange._unAcked) {\n      var task = exchange._unAcked[id];\n      task.emit('ack error', err);\n      delete exchange._unAcked[id];\n    }\n  };\n}\n\nExchange.prototype._onMethod = function (channel, method, args) {\n  this.emit(method.name, args);\n\n  if (this._handleTaskReply.apply(this, arguments))\n    return true;\n\n  var cb;\n\n  switch (method) {\n    case methods.channelOpenOk:\n      this._sequence = null;\n\n      if (!this._addedExchangeErrorHandler) {\n        var errorHandler = createExchangeErrorHandlerFor(this);\n        this.connection.on('error', errorHandler);\n        this.on('error', errorHandler);\n        this._addedExchangeErrorHandler = true;\n      }\n\n      // Pre-baked exchanges don't need to be declared\n      if (/^$|(amq\\.)/.test(this.name)) {\n        //If confirm mode is specified we have to set it no matter the exchange.\n        if (this.options.confirm) {\n          this._confirmSelect(channel);\n          return;\n        }\n\n        this.state = 'open';\n        // - issue #33 fix\n        if (this._openCallback) {\n         this._openCallback(this);\n         this._openCallback = null;\n        }\n        // --\n        this.emit('open');\n\n      // For if we want to delete a exchange,\n      // we dont care if all of the options match.\n      } else if (this.options.noDeclare) {\n        if (this.options.confirm) {\n          this._confirmSelect(channel);\n          return;\n        }\n\n        this.state = 'open';\n\n        if (this._openCallback) {\n         this._openCallback(this);\n         this._openCallback = null;\n        }\n\n        this.emit('open');\n      } else {\n        this.connection._sendMethod(channel, methods.exchangeDeclare,\n            { reserved1:  0\n            , reserved2:  false\n            , reserved3:  false\n            , exchange:   this.name\n            , type:       this.options.type || 'topic'\n            , passive:    !!this.options.passive\n            , durable:    !!this.options.durable\n            , autoDelete: !!this.options.autoDelete\n            , internal:   !!this.options.internal\n            , noWait:     false\n            , \"arguments\":this.options.arguments || {}\n            });\n        this.state = 'declaring';\n      }\n      break;\n\n    case methods.exchangeDeclareOk:\n      if (this.options.confirm) {\n        this._confirmSelect(channel);\n      } else {\n\n        this.state = 'open';\n        this.emit('open');\n        if (this._openCallback) {\n          this._openCallback(this);\n          this._openCallback = null;\n        }\n      }\n      break;\n\n    case methods.confirmSelectOk:\n      this._sequence = 1;\n\n      this.state = 'open';\n      this.emit('open');\n      if (this._openCallback) {\n        this._openCallback(this);\n        this._openCallback = null;\n      }\n      break;\n\n    case methods.channelClose:\n      this.state = \"closed\";\n      this.closeOK();\n      this.connection.exchangeClosed(this.name);\n      var e = new Error(args.replyText);\n      e.code = args.replyCode;\n      this.emit('error', e);\n      this.emit('close');\n      break;\n\n    case methods.channelCloseOk:\n      this.connection.exchangeClosed(this.name);\n      this.emit('close');\n      break;\n\n\n    case methods.basicAck:\n      this.emit('basic-ack', args);\n      var sequenceNumber = args.deliveryTag.readUInt32BE(4), tag;\n      debug && debug(\"basic-ack, sequence: \", sequenceNumber);\n\n      if (sequenceNumber === 0 && args.multiple === true) {\n        // we must ack everything\n        for (tag in this._unAcked) {\n          this._unAcked[tag].emit('ack');\n          delete this._unAcked[tag];\n        }\n      } else if (sequenceNumber !== 0 && args.multiple === true) {\n        // we must ack everything before the delivery tag\n        for (tag in this._unAcked) {\n          if (tag <= sequenceNumber) {\n            this._unAcked[tag].emit('ack');\n            delete this._unAcked[tag];\n          }\n        }\n      } else if (this._unAcked[sequenceNumber] && args.multiple === false) {\n        // simple single ack\n        this._unAcked[sequenceNumber].emit('ack');\n        delete this._unAcked[sequenceNumber];\n      }\n      break;\n\n    case methods.basicReturn:\n      this.emit('basic-return', args);\n      break;\n\n    case methods.exchangeBindOk:\n      if (this._bindCallback) {\n        // setting this._bindCallback to null before calling the callback allows for a subsequent bind within the callback\n        cb = this._bindCallback;\n        this._bindCallback = null;\n        cb(this);\n      }\n      break;\n\n    case methods.exchangeUnbindOk:\n      if (this._unbindCallback) {\n        cb = this._unbindCallback;\n        this._unbindCallback = null;\n        cb(this);\n      }\n      break;\n\n    default:\n      throw new Error(\"Uncaught method '\" + method.name + \"' with args \" +\n        JSON.stringify(args));\n  }\n\n  this._tasksFlush();\n};\n\n// exchange.publish('routing.key', 'body');\n//\n// the third argument can specify additional options\n// - mandatory (boolean, default false)\n// - immediate (boolean, default false)\n// - contentType (default 'application/octet-stream')\n// - contentEncoding\n// - headers\n// - deliveryMode\n// - priority (0-9)\n// - correlationId\n// - replyTo\n// - expiration\n// - messageId\n// - timestamp\n// - userId\n// - appId\n// - clusterId\n//\n// the callback is optional and is only used when confirm is turned on for the exchange\n\nExchange.prototype.publish = function (routingKey, data, options, callback) {\n  var self = this;\n  callback = callback || function() {};\n\n  if (this.connection._blocked) {\n    return callback(true, new Error('Connection is blocked, server reason: ' + this.connection._blockedReason));\n  }\n\n  if (this.state !== 'open') {\n    this._sequence = null;\n    return callback(true, new Error('Can not publish: exchange is not open'));\n  }\n\n  if (this.options.confirm && !this._readyToPublishWithConfirms()) {\n    return callback(true, new Error('Not yet ready to publish with confirms'));\n  }\n\n  options = _.assignIn({}, options || {});\n  options.routingKey = routingKey;\n  options.exchange   = self.name;\n  options.mandatory  = options.mandatory ? true : false;\n  options.immediate  = options.immediate ? true : false;\n  options.reserved1  = 0;\n\n  var task = this._taskPush(null, function () {\n    self.connection._sendMethod(self.channel, methods.basicPublish, options);\n    // This interface is probably not appropriate for streaming large files.\n    // (Of course it's arguable about whether AMQP is the appropriate\n    // transport for large files.) The content header wants to know the size\n    // of the data before sending it - so there's no point in trying to have a\n    // general streaming interface - streaming messages of unknown size simply\n    // isn't possible with AMQP. This is all to say, don't send big messages.\n    // If you need to stream something large, chunk it yourself.\n    self.connection._sendBody(self.channel, data, options);\n  });\n\n  if (self.options.confirm) self._awaitConfirm(task, callback);\n  return task;\n};\n\n// registers tasks for confirms\nExchange.prototype._awaitConfirm = function _awaitConfirm (task, callback) {\n  if (!this._addedExchangeErrorHandler) {\n    // if connection fails, we want to ack error all unacked publishes.\n    this.connection.on('error', createExchangeErrorHandlerFor(this));\n    this.on('error', createExchangeErrorHandlerFor(this));\n    this._addedExchangeErrorHandler = true;\n  }\n\n  debug && debug('awaiting confirmation for ' + this._sequence);\n  task.sequence = this._sequence;\n  this._unAcked[this._sequence] = task;\n  this._sequence++;\n\n  if ('function' != typeof callback) return;\n\n  task.once('ack error', function (err) {\n    task.removeAllListeners();\n    callback(true, err);\n  });\n\n  task.once('ack', function () {\n    task.removeAllListeners();\n    callback(false);\n  });\n};\n\n// do any necessary cleanups eg. after queue destruction\nExchange.prototype.cleanup = function() {\n  if (this.binds === 0) { // don't keep reference open if unused\n    this.connection.exchangeClosed(this.name);\n  }\n};\n\nExchange.prototype.destroy = function (ifUnused) {\n  var self = this;\n  return this._taskPush(methods.exchangeDeleteOk, function () {\n    self.connection.exchangeClosed(self.name);\n    self.connection._sendMethod(self.channel, methods.exchangeDelete,\n        { reserved1: 0\n        , exchange: self.name\n        , ifUnused: ifUnused ? true : false\n        , noWait: false\n        });\n  });\n};\n\n// E2E Unbind\n// support RabbitMQ's exchange-to-exchange binding extension\n// http://www.rabbitmq.com/e2e.html\nExchange.prototype.unbind = function (/* exchange, routingKey [, bindCallback] */) {\n  var self = this;\n\n  // Both arguments are required. The binding to the destination\n  // exchange/routingKey will be unbound.\n\n  var exchange    = arguments[0]\n    , routingKey  = arguments[1]\n    , callback    = arguments[2]\n  ;\n\n  if (callback) this._unbindCallback = callback;\n\n  return this._taskPush(methods.exchangeUnbindOk, function () {\n    var source = exchange instanceof Exchange ? exchange.name : exchange;\n    var destination = self.name;\n\n    if (source in self.connection.exchanges) {\n      delete self.sourceExchanges[source];\n      self.connection.exchanges[source].exchangeBinds--;\n    }\n\n    self.connection._sendMethod(self.channel, methods.exchangeUnbind,\n        { reserved1: 0\n        , destination: destination\n        , source: source\n        , routingKey: routingKey\n        , noWait: false\n        , \"arguments\": {}\n        });\n  });\n};\n\n// E2E Bind\n// support RabbitMQ's exchange-to-exchange binding extension\n// http://www.rabbitmq.com/e2e.html\nExchange.prototype.bind = function (/* exchange, routingKey [, bindCallback] */) {\n  var self = this;\n\n  // Two arguments are required. The binding to the destination\n  // exchange/routingKey will be established.\n\n  var exchange    = arguments[0]\n    , routingKey  = arguments[1]\n    , callback    = arguments[2]\n  ;\n\n  if (callback) this._bindCallback = callback;\n\n  var source = exchange instanceof Exchange ? exchange.name : exchange;\n  var destination = self.name;\n\n  if(source in self.connection.exchanges) {\n    self.sourceExchanges[source] = self.connection.exchanges[source];\n    self.connection.exchanges[source].exchangeBinds++;\n  }\n\n  self.connection._sendMethod(self.channel, methods.exchangeBind,\n      { reserved1: 0\n      , destination: destination\n      , source: source\n      , routingKey: routingKey\n      , noWait: false\n      , \"arguments\": {}\n      });\n\n};\n\n// E2E Bind\n// support RabbitMQ's exchange-to-exchange binding extension\n// http://www.rabbitmq.com/e2e.html\nExchange.prototype.bind_headers = function (/* exchange, routing [, bindCallback] */) {\n  var self = this;\n\n  // Two arguments are required. The binding to the destination\n  // exchange/routingKey will be established.\n\n  var exchange = arguments[0]\n    , routing  = arguments[1]\n    , callback = arguments[2]\n  ;\n\n  if (callback) this._bindCallback = callback;\n\n  var source = exchange instanceof Exchange ? exchange.name : exchange;\n  var destination = self.name;\n\n  if (source in self.connection.exchanges) {\n    self.sourceExchanges[source] = self.connection.exchanges[source];\n    self.connection.exchanges[source].exchangeBinds++;\n  }\n\n  self.connection._sendMethod(self.channel, methods.exchangeBind,\n    { reserved1: 0\n        , destination: destination\n        , source: source\n        , routingKey: ''\n        , noWait: false\n        , \"arguments\": routing\n    });\n};\n\nExchange.prototype._confirmSelect = function(channel) {\n  this.connection._sendMethod(channel, methods.confirmSelect, { noWait: false });\n};\n\nExchange.prototype._readyToPublishWithConfirms = function() {\n  return this._sequence != null;\n};\n"]},"metadata":{},"sourceType":"script"}