{"ast":null,"code":"'use strict';\n\nvar jspack = require('../jspack').jspack;\n\nvar serializer = module.exports = {\n  serializeFloat: function (b, size, value, bigEndian) {\n    var jp = new jspack(bigEndian);\n\n    switch (size) {\n      case 4:\n        var x = jp.Pack('f', [value]);\n\n        for (var i = 0; i < x.length; ++i) b[b.used++] = x[i];\n\n        break;\n\n      case 8:\n        var x = jp.Pack('d', [value]);\n\n        for (var i = 0; i < x.length; ++i) b[b.used++] = x[i];\n\n        break;\n\n      default:\n        throw new Error(\"Unknown floating point size\");\n    }\n  },\n  serializeInt: function (b, size, int) {\n    if (b.used + size > b.length) {\n      throw new Error(\"write out of bounds\");\n    } // Only 4 cases - just going to be explicit instead of looping.\n\n\n    switch (size) {\n      // octet\n      case 1:\n        b[b.used++] = int;\n        break;\n      // short\n\n      case 2:\n        b[b.used++] = (int & 0xFF00) >> 8;\n        b[b.used++] = (int & 0x00FF) >> 0;\n        break;\n      // long\n\n      case 4:\n        b[b.used++] = (int & 0xFF000000) >> 24;\n        b[b.used++] = (int & 0x00FF0000) >> 16;\n        b[b.used++] = (int & 0x0000FF00) >> 8;\n        b[b.used++] = (int & 0x000000FF) >> 0;\n        break;\n      // long long\n\n      case 8:\n        b[b.used++] = (int & 0xFF00000000000000) >> 56;\n        b[b.used++] = (int & 0x00FF000000000000) >> 48;\n        b[b.used++] = (int & 0x0000FF0000000000) >> 40;\n        b[b.used++] = (int & 0x000000FF00000000) >> 32;\n        b[b.used++] = (int & 0x00000000FF000000) >> 24;\n        b[b.used++] = (int & 0x0000000000FF0000) >> 16;\n        b[b.used++] = (int & 0x000000000000FF00) >> 8;\n        b[b.used++] = (int & 0x00000000000000FF) >> 0;\n        break;\n\n      default:\n        throw new Error(\"Bad size\");\n    }\n  },\n  serializeShortString: function (b, string) {\n    if (typeof string != \"string\") {\n      throw new Error(\"param must be a string\");\n    }\n\n    var byteLength = Buffer.byteLength(string, 'utf8');\n\n    if (byteLength > 0xFF) {\n      throw new Error(\"String too long for 'shortstr' parameter\");\n    }\n\n    if (1 + byteLength + b.used >= b.length) {\n      throw new Error(\"Not enough space in buffer for 'shortstr'\");\n    }\n\n    b[b.used++] = byteLength;\n    b.write(string, b.used, 'utf8');\n    b.used += byteLength;\n  },\n  serializeLongString: function (b, string) {\n    // we accept string, object, or buffer for this parameter.\n    // in the case of string we serialize it to utf8.\n    if (typeof string == 'string') {\n      var byteLength = Buffer.byteLength(string, 'utf8');\n      serializer.serializeInt(b, 4, byteLength);\n      b.write(string, b.used, 'utf8');\n      b.used += byteLength;\n    } else if (typeof string == 'object') {\n      serializer.serializeTable(b, string);\n    } else {\n      // data is Buffer\n      var byteLength = string.length;\n      serializer.serializeInt(b, 4, byteLength);\n      b.write(string, b.used); // memcpy\n\n      b.used += byteLength;\n    }\n  },\n  serializeDate: function (b, date) {\n    serializer.serializeInt(b, 8, date.valueOf() / 1000);\n  },\n  serializeBuffer: function (b, buffer) {\n    serializer.serializeInt(b, 4, buffer.length);\n    buffer.copy(b, b.used, 0);\n    b.used += buffer.length;\n  },\n  serializeBase64: function (b, buffer) {\n    serializer.serializeLongString(b, buffer.toString('base64'));\n  },\n  isBigInt: function (value) {\n    return value > 0xffffffff;\n  },\n  getCode: function (dec) {\n    var hexArray = \"0123456789ABCDEF\".split('');\n    var code1 = Math.floor(dec / 16);\n    var code2 = dec - code1 * 16;\n    return hexArray[code2];\n  },\n  isFloat: function (value) {\n    return value === +value && value !== (value | 0);\n  },\n  serializeValue: function (b, value) {\n    switch (typeof value) {\n      case 'string':\n        b[b.used++] = 'S'.charCodeAt(0);\n        serializer.serializeLongString(b, value);\n        break;\n\n      case 'number':\n        if (!serializer.isFloat(value)) {\n          if (serializer.isBigInt(value)) {\n            // 64-bit uint\n            b[b.used++] = 'l'.charCodeAt(0);\n            serializer.serializeInt(b, 8, value);\n          } else {\n            //32-bit uint\n            b[b.used++] = 'I'.charCodeAt(0);\n            serializer.serializeInt(b, 4, value);\n          }\n        } else {\n          //64-bit float\n          b[b.used++] = 'd'.charCodeAt(0);\n          serializer.serializeFloat(b, 8, value);\n        }\n\n        break;\n\n      case 'boolean':\n        b[b.used++] = 't'.charCodeAt(0);\n        b[b.used++] = value;\n        break;\n\n      default:\n        if (value instanceof Date) {\n          b[b.used++] = 'T'.charCodeAt(0);\n          serializer.serializeDate(b, value);\n        } else if (value instanceof Buffer) {\n          b[b.used++] = 'x'.charCodeAt(0);\n          serializer.serializeBuffer(b, value);\n        } else if (Array.isArray(value)) {\n          b[b.used++] = 'A'.charCodeAt(0);\n          serializer.serializeArray(b, value);\n        } else if (typeof value === 'object') {\n          b[b.used++] = 'F'.charCodeAt(0);\n          serializer.serializeTable(b, value);\n        } else {\n          throw new Error(\"unsupported type in amqp table: \" + typeof value);\n        }\n\n    }\n  },\n  serializeTable: function (b, object) {\n    if (typeof object != \"object\") {\n      throw new Error(\"param must be an object\");\n    } // Save our position so that we can go back and write the length of this table\n    // at the beginning of the packet (once we know how many entries there are).\n\n\n    var lengthIndex = b.used;\n    b.used += 4; // sizeof long\n\n    var startIndex = b.used;\n\n    for (var key in object) {\n      if (!object.hasOwnProperty(key)) continue;\n      serializer.serializeShortString(b, key);\n      serializer.serializeValue(b, object[key]);\n    }\n\n    var endIndex = b.used;\n    b.used = lengthIndex;\n    serializer.serializeInt(b, 4, endIndex - startIndex);\n    b.used = endIndex;\n  },\n  serializeArray: function (b, arr) {\n    // Save our position so that we can go back and write the byte length of this array\n    // at the beginning of the packet (once we have serialized all elements).\n    var lengthIndex = b.used;\n    b.used += 4; // sizeof long\n\n    var startIndex = b.used;\n    var len = arr.length;\n\n    for (var i = 0; i < len; i++) {\n      serializer.serializeValue(b, arr[i]);\n    }\n\n    var endIndex = b.used;\n    b.used = lengthIndex;\n    serializer.serializeInt(b, 4, endIndex - startIndex);\n    b.used = endIndex;\n  },\n  serializeFields: function (buffer, fields, args, strict) {\n    var bitField = 0;\n    var bitIndex = 0;\n\n    for (var i = 0; i < fields.length; i++) {\n      var field = fields[i];\n      var domain = field.domain;\n\n      if (!(field.name in args)) {\n        if (strict) {\n          throw new Error(\"Missing field '\" + field.name + \"' of type '\" + domain + \"' while executing AMQP method '\" + arguments.callee.caller.arguments[1].name + \"'\");\n        }\n\n        continue;\n      }\n\n      var param = args[field.name]; //debug(\"domain: \" + domain + \" param: \" + param);\n\n      switch (domain) {\n        case 'bit':\n          if (typeof param != \"boolean\") {\n            throw new Error(\"Unmatched field \" + JSON.stringify(field));\n          }\n\n          if (param) bitField |= 1 << bitIndex;\n          bitIndex++;\n\n          if (!fields[i + 1] || fields[i + 1].domain != 'bit') {\n            //debug('SET bit field ' + field.name + ' 0x' + bitField.toString(16));\n            buffer[buffer.used++] = bitField;\n            bitField = 0;\n            bitIndex = 0;\n          }\n\n          break;\n\n        case 'octet':\n          if (typeof param != \"number\" || param > 0xFF) {\n            throw new Error(\"Unmatched field \" + JSON.stringify(field));\n          }\n\n          buffer[buffer.used++] = param;\n          break;\n\n        case 'short':\n          if (typeof param != \"number\" || param > 0xFFFF) {\n            throw new Error(\"Unmatched field \" + JSON.stringify(field));\n          }\n\n          serializer.serializeInt(buffer, 2, param);\n          break;\n\n        case 'long':\n          if (typeof param != \"number\" || param > 0xFFFFFFFF) {\n            throw new Error(\"Unmatched field \" + JSON.stringify(field));\n          }\n\n          serializer.serializeInt(buffer, 4, param);\n          break;\n        // In a previous version this shared code with 'longlong', which caused problems when passed Date\n        // integers. Nobody expects to pass a Buffer here, 53 bits is still 28 million years after 1970, we'll be fine.\n\n        case 'timestamp':\n          serializer.serializeInt(buffer, 8, param);\n          break;\n\n        case 'longlong':\n          for (var j = 0; j < 8; j++) {\n            buffer[buffer.used++] = param[j];\n          }\n\n          break;\n\n        case 'shortstr':\n          if (typeof param != \"string\" || param.length > 0xFF) {\n            throw new Error(\"Unmatched field \" + JSON.stringify(field));\n          }\n\n          serializer.serializeShortString(buffer, param);\n          break;\n\n        case 'longstr':\n          serializer.serializeLongString(buffer, param);\n          break;\n\n        case 'table':\n          if (typeof param != \"object\") {\n            throw new Error(\"Unmatched field \" + JSON.stringify(field));\n          }\n\n          serializer.serializeTable(buffer, param);\n          break;\n\n        default:\n          throw new Error(\"Unknown domain value type \" + domain);\n      }\n    }\n  }\n};","map":{"version":3,"sources":["/Users/alexyang/Desktop/todolist/Traffic-Generator/node_modules/amqp/lib/serializer.js"],"names":["jspack","require","serializer","module","exports","serializeFloat","b","size","value","bigEndian","jp","x","Pack","i","length","used","Error","serializeInt","int","serializeShortString","string","byteLength","Buffer","write","serializeLongString","serializeTable","serializeDate","date","valueOf","serializeBuffer","buffer","copy","serializeBase64","toString","isBigInt","getCode","dec","hexArray","split","code1","Math","floor","code2","isFloat","serializeValue","charCodeAt","Date","Array","isArray","serializeArray","object","lengthIndex","startIndex","key","hasOwnProperty","endIndex","arr","len","serializeFields","fields","args","strict","bitField","bitIndex","field","domain","name","arguments","callee","caller","param","JSON","stringify","j"],"mappings":"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","sourcesContent":["'use strict';\n\nvar jspack = require('../jspack').jspack;\n\nvar serializer = module.exports = {\n  serializeFloat: function(b, size, value, bigEndian) {\n    var jp = new jspack(bigEndian);\n\n    switch(size) {\n      case 4:\n        var x = jp.Pack('f', [value]);\n        for (var i = 0; i < x.length; ++i)\n          b[b.used++] = x[i];\n        break;\n\n      case 8:\n        var x = jp.Pack('d', [value]);\n        for (var i = 0; i < x.length; ++i)\n          b[b.used++] = x[i];\n        break;\n\n      default:\n        throw new Error(\"Unknown floating point size\");\n    }\n  },\n\n  serializeInt: function (b, size, int) {\n    if (b.used + size > b.length) {\n      throw new Error(\"write out of bounds\");\n    }\n\n    // Only 4 cases - just going to be explicit instead of looping.\n\n    switch (size) {\n      // octet\n      case 1:\n        b[b.used++] = int;\n        break;\n\n      // short\n      case 2:\n        b[b.used++] = (int & 0xFF00) >> 8;\n        b[b.used++] = (int & 0x00FF) >> 0;\n        break;\n\n      // long\n      case 4:\n        b[b.used++] = (int & 0xFF000000) >> 24;\n        b[b.used++] = (int & 0x00FF0000) >> 16;\n        b[b.used++] = (int & 0x0000FF00) >> 8;\n        b[b.used++] = (int & 0x000000FF) >> 0;\n        break;\n\n\n      // long long\n      case 8:\n        b[b.used++] = (int & 0xFF00000000000000) >> 56;\n        b[b.used++] = (int & 0x00FF000000000000) >> 48;\n        b[b.used++] = (int & 0x0000FF0000000000) >> 40;\n        b[b.used++] = (int & 0x000000FF00000000) >> 32;\n        b[b.used++] = (int & 0x00000000FF000000) >> 24;\n        b[b.used++] = (int & 0x0000000000FF0000) >> 16;\n        b[b.used++] = (int & 0x000000000000FF00) >> 8;\n        b[b.used++] = (int & 0x00000000000000FF) >> 0;\n        break;\n\n      default:\n        throw new Error(\"Bad size\");\n    }\n  },\n\n\n  serializeShortString: function (b, string) {\n    if (typeof(string) != \"string\") {\n      throw new Error(\"param must be a string\");\n    }\n    var byteLength = Buffer.byteLength(string, 'utf8');\n    if (byteLength > 0xFF) {\n      throw new Error(\"String too long for 'shortstr' parameter\");\n    }\n    if (1 + byteLength + b.used >= b.length) {\n      throw new Error(\"Not enough space in buffer for 'shortstr'\");\n    }\n    b[b.used++] = byteLength;\n    b.write(string, b.used, 'utf8');\n    b.used += byteLength;\n  },\n\n  serializeLongString: function(b, string) {\n    // we accept string, object, or buffer for this parameter.\n    // in the case of string we serialize it to utf8.\n    if (typeof(string) == 'string') {\n      var byteLength = Buffer.byteLength(string, 'utf8');\n      serializer.serializeInt(b, 4, byteLength);\n      b.write(string, b.used, 'utf8');\n      b.used += byteLength;\n    } else if (typeof(string) == 'object') {\n      serializer.serializeTable(b, string);\n    } else {\n      // data is Buffer\n      var byteLength = string.length;\n      serializer.serializeInt(b, 4, byteLength);\n      b.write(string, b.used); // memcpy\n      b.used += byteLength;\n    }\n  },\n\n  serializeDate: function(b, date) {\n    serializer.serializeInt(b, 8, date.valueOf() / 1000);\n  },\n\n  serializeBuffer: function(b, buffer) {\n    serializer.serializeInt(b, 4, buffer.length);\n    buffer.copy(b, b.used, 0);\n    b.used += buffer.length;\n  },\n\n  serializeBase64: function(b, buffer) {\n    serializer.serializeLongString(b, buffer.toString('base64'));\n  },\n\n  isBigInt: function(value) {\n    return value > 0xffffffff;\n  },\n\n  getCode: function(dec) {\n    var hexArray = \"0123456789ABCDEF\".split('');\n    var code1 = Math.floor(dec / 16);\n    var code2 = dec - code1 * 16;\n    return hexArray[code2];\n  },\n\n  isFloat: function(value){\n    return value === +value && value !== (value|0);\n  },\n\n  serializeValue: function(b, value) {\n    switch (typeof(value)) {\n      case 'string':\n        b[b.used++] = 'S'.charCodeAt(0);\n        serializer.serializeLongString(b, value);\n        break;\n\n      case 'number':\n        if (!serializer.isFloat(value)) {\n          if (serializer.isBigInt(value)) {\n            // 64-bit uint\n            b[b.used++] = 'l'.charCodeAt(0);\n            serializer.serializeInt(b, 8, value);\n          } else {\n            //32-bit uint\n            b[b.used++] = 'I'.charCodeAt(0);\n            serializer.serializeInt(b, 4, value);\n          }\n        } else {\n          //64-bit float\n          b[b.used++] = 'd'.charCodeAt(0);\n          serializer.serializeFloat(b, 8, value);\n        }\n        break;\n\n      case 'boolean':\n        b[b.used++] = 't'.charCodeAt(0);\n        b[b.used++] = value;\n        break;\n\n      default:\n        if (value instanceof Date) {\n          b[b.used++] = 'T'.charCodeAt(0);\n          serializer.serializeDate(b, value);\n        } else if (value instanceof Buffer) {\n          b[b.used++] = 'x'.charCodeAt(0);\n          serializer.serializeBuffer(b, value);\n        } else if (Array.isArray(value)) {\n          b[b.used++] = 'A'.charCodeAt(0);\n          serializer.serializeArray(b, value);\n        } else if (typeof(value) === 'object') {\n          b[b.used++] = 'F'.charCodeAt(0);\n          serializer.serializeTable(b, value);\n        } else {\n          throw new Error(\"unsupported type in amqp table: \" + typeof(value));\n        }\n    }\n  },\n\n  serializeTable: function(b, object) {\n    if (typeof(object) != \"object\") {\n      throw new Error(\"param must be an object\");\n    }\n\n    // Save our position so that we can go back and write the length of this table\n    // at the beginning of the packet (once we know how many entries there are).\n    var lengthIndex = b.used;\n    b.used += 4; // sizeof long\n    var startIndex = b.used;\n\n    for (var key in object) {\n      if (!object.hasOwnProperty(key)) continue;\n      serializer.serializeShortString(b, key);\n      serializer.serializeValue(b, object[key]);\n    }\n\n    var endIndex = b.used;\n    b.used = lengthIndex;\n    serializer.serializeInt(b, 4, endIndex - startIndex);\n    b.used = endIndex;\n  },\n\n  serializeArray: function(b, arr) {\n    // Save our position so that we can go back and write the byte length of this array\n    // at the beginning of the packet (once we have serialized all elements).\n    var lengthIndex = b.used;\n    b.used += 4; // sizeof long\n    var startIndex = b.used;\n\n    var len = arr.length;\n    for (var i = 0; i < len; i++) {\n      serializer.serializeValue(b, arr[i]);\n    }\n\n    var endIndex = b.used;\n    b.used = lengthIndex;\n    serializer.serializeInt(b, 4, endIndex - startIndex);\n    b.used = endIndex;\n  },\n\n  serializeFields: function(buffer, fields, args, strict) {\n    var bitField = 0;\n    var bitIndex = 0;\n    for (var i = 0; i < fields.length; i++) {\n      var field = fields[i];\n      var domain = field.domain;\n      if (!(field.name in args)) {\n        if (strict) {\n          throw new Error(\"Missing field '\" + field.name + \"' of type '\" + domain + \"' while executing AMQP method '\" + \n            arguments.callee.caller.arguments[1].name + \"'\");\n        }\n        continue;\n      }\n\n      var param = args[field.name];\n\n      //debug(\"domain: \" + domain + \" param: \" + param);\n\n      switch (domain) {\n        case 'bit':\n          if (typeof(param) != \"boolean\") {\n            throw new Error(\"Unmatched field \" + JSON.stringify(field));\n          }\n\n          if (param) bitField |= (1 << bitIndex);\n          bitIndex++;\n\n          if (!fields[i+1] || fields[i+1].domain != 'bit') {\n            //debug('SET bit field ' + field.name + ' 0x' + bitField.toString(16));\n            buffer[buffer.used++] = bitField;\n            bitField = 0;\n            bitIndex = 0;\n          }\n          break;\n\n        case 'octet':\n          if (typeof(param) != \"number\" || param > 0xFF) {\n            throw new Error(\"Unmatched field \" + JSON.stringify(field));\n          }\n          buffer[buffer.used++] = param;\n          break;\n\n        case 'short':\n          if (typeof(param) != \"number\" || param > 0xFFFF) {\n            throw new Error(\"Unmatched field \" + JSON.stringify(field));\n          }\n          serializer.serializeInt(buffer, 2, param);\n          break;\n\n        case 'long':\n          if (typeof(param) != \"number\" || param > 0xFFFFFFFF) {\n            throw new Error(\"Unmatched field \" + JSON.stringify(field));\n          }\n          serializer.serializeInt(buffer, 4, param);\n          break;\n\n        // In a previous version this shared code with 'longlong', which caused problems when passed Date\n        // integers. Nobody expects to pass a Buffer here, 53 bits is still 28 million years after 1970, we'll be fine.\n        case 'timestamp':\n          serializer.serializeInt(buffer, 8, param);\n          break;\n\n        case 'longlong':\n          for (var j = 0; j < 8; j++) {\n            buffer[buffer.used++] = param[j];\n          }\n          break;\n\n        case 'shortstr':\n          if (typeof(param) != \"string\" || param.length > 0xFF) {\n            throw new Error(\"Unmatched field \" + JSON.stringify(field));\n          }\n          serializer.serializeShortString(buffer, param);\n          break;\n\n        case 'longstr':\n          serializer.serializeLongString(buffer, param);\n          break;\n\n        case 'table':\n          if (typeof(param) != \"object\") {\n            throw new Error(\"Unmatched field \" + JSON.stringify(field));\n          }\n          serializer.serializeTable(buffer, param);\n          break;\n\n        default:\n          throw new Error(\"Unknown domain value type \" + domain);\n      }\n    }\n  }\n};\n"]},"metadata":{},"sourceType":"script"}