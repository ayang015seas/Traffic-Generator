{"ast":null,"code":"'use strict';\n\nvar events = require('events');\n\nvar util = require('util');\n\nvar fs = require('fs');\n\nvar Promise = require('./promise').Promise;\n\nvar definitions = require('./definitions');\n\nvar methods = definitions.methods; // This class is not exposed to the user. Queue and Exchange are subclasses\n// of Channel. This just provides a task queue.\n\nvar Channel = module.exports = function Channel(connection, channel) {\n  events.EventEmitter.call(this); // Unlimited listeners. Helps when e.g. publishing high-volume messages,\n  // 10 is far too low.\n\n  this.setMaxListeners(0);\n  this.channel = channel;\n  this.connection = connection;\n  this._tasks = [];\n  this.reconnect();\n};\n\nutil.inherits(Channel, events.EventEmitter);\n\nChannel.prototype.closeOK = function () {\n  this.connection._sendMethod(this.channel, methods.channelCloseOk, {\n    reserved1: \"\"\n  });\n};\n\nChannel.prototype.reconnect = function () {\n  this.connection._sendMethod(this.channel, methods.channelOpen, {\n    reserved1: \"\"\n  });\n};\n\nChannel.prototype._taskPush = function (reply, cb) {\n  var promise = new Promise();\n\n  this._tasks.push({\n    promise: promise,\n    reply: reply,\n    sent: false,\n    cb: cb\n  });\n\n  this._tasksFlush();\n\n  return promise;\n};\n\nChannel.prototype._tasksFlush = function () {\n  if (this.state != 'open') return;\n\n  for (var i = 0; i < this._tasks.length; i++) {\n    var task = this._tasks[i];\n    if (task.sent) continue;\n    task.cb();\n    task.sent = true;\n\n    if (!task.reply) {\n      // if we don't expect a reply, just delete it now\n      this._tasks.splice(i, 1);\n\n      i = i - 1;\n    }\n  }\n};\n\nChannel.prototype._handleTaskReply = function (channel, method, args) {\n  var task, i;\n\n  for (i = 0; i < this._tasks.length; i++) {\n    if (this._tasks[i].reply == method) {\n      task = this._tasks[i];\n\n      this._tasks.splice(i, 1);\n\n      task.promise.emitSuccess(args);\n\n      this._tasksFlush();\n\n      return true;\n    }\n  }\n\n  return false;\n};\n\nChannel.prototype._onChannelMethod = function (channel, method, args) {\n  switch (method) {\n    case methods.channelCloseOk:\n      delete this.connection.channels[this.channel];\n      this.state = 'closed';\n    // TODO should this be falling through?\n\n    default:\n      this._onMethod(channel, method, args);\n\n  }\n};\n\nChannel.prototype.close = function (reason) {\n  this.state = 'closing';\n\n  this.connection._sendMethod(this.channel, methods.channelClose, {\n    'replyText': reason ? reason : 'Goodbye from node',\n    'replyCode': 200,\n    'classId': 0,\n    'methodId': 0\n  });\n};","map":{"version":3,"sources":["/Users/alexyang/Desktop/todolist/Traffic-Generator/node_modules/amqp/lib/channel.js"],"names":["events","require","util","fs","Promise","definitions","methods","Channel","module","exports","connection","channel","EventEmitter","call","setMaxListeners","_tasks","reconnect","inherits","prototype","closeOK","_sendMethod","channelCloseOk","reserved1","channelOpen","_taskPush","reply","cb","promise","push","sent","_tasksFlush","state","i","length","task","splice","_handleTaskReply","method","args","emitSuccess","_onChannelMethod","channels","_onMethod","close","reason","channelClose"],"mappings":"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","sourcesContent":["'use strict';\nvar events = require('events');\nvar util = require('util');\nvar fs = require('fs');\nvar Promise = require('./promise').Promise;\nvar definitions = require('./definitions');\nvar methods = definitions.methods;\n\n// This class is not exposed to the user. Queue and Exchange are subclasses\n// of Channel. This just provides a task queue.\nvar Channel = module.exports = function Channel (connection, channel) {\n  events.EventEmitter.call(this);\n\n  // Unlimited listeners. Helps when e.g. publishing high-volume messages,\n  // 10 is far too low.\n  this.setMaxListeners(0);\n\n  this.channel = channel;\n  this.connection = connection;\n  this._tasks = [];\n\n  this.reconnect();\n};\nutil.inherits(Channel, events.EventEmitter);\n\nChannel.prototype.closeOK = function() {\n  this.connection._sendMethod(this.channel, methods.channelCloseOk, {reserved1: \"\"});\n};\n\nChannel.prototype.reconnect = function () {\n  this.connection._sendMethod(this.channel, methods.channelOpen, {reserved1: \"\"});\n};\n\nChannel.prototype._taskPush = function (reply, cb) {\n  var promise = new Promise();\n  this._tasks.push({\n    promise: promise,\n    reply: reply,\n    sent: false,\n    cb: cb\n  });\n  this._tasksFlush();\n  return promise;\n};\n\nChannel.prototype._tasksFlush = function () {\n  if (this.state != 'open') return;\n\n  for (var i = 0; i < this._tasks.length; i++) {\n    var task = this._tasks[i];\n    if (task.sent) continue;\n    task.cb();\n    task.sent = true;\n    if (!task.reply) {\n      // if we don't expect a reply, just delete it now\n      this._tasks.splice(i, 1);\n      i = i-1;\n    }\n  }\n};\n\nChannel.prototype._handleTaskReply = function (channel, method, args) {\n  var task, i;\n\n  for (i = 0; i < this._tasks.length; i++) {\n    if (this._tasks[i].reply == method) {\n      task = this._tasks[i];\n      this._tasks.splice(i, 1);\n      task.promise.emitSuccess(args);\n      this._tasksFlush();\n      return true;\n    }\n  }\n\n  return false;\n};\n\nChannel.prototype._onChannelMethod = function(channel, method, args) {\n  switch (method) {\n    case methods.channelCloseOk:\n      delete this.connection.channels[this.channel];\n      this.state = 'closed';\n      // TODO should this be falling through?\n    default:\n      this._onMethod(channel, method, args);\n  }\n};\n\nChannel.prototype.close = function(reason) {\n  this.state = 'closing';\n  this.connection._sendMethod(this.channel, methods.channelClose,\n                              {'replyText': reason ? reason : 'Goodbye from node',\n                               'replyCode': 200,\n                               'classId': 0,\n                               'methodId': 0});\n};\n"]},"metadata":{},"sourceType":"script"}