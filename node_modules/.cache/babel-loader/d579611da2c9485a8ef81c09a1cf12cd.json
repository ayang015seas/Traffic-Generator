{"ast":null,"code":"'use strict';\n\nvar events = require('events');\n\nvar util = require('util');\n\nvar net = require('net');\n\nvar tls = require('tls');\n\nvar fs = require('fs');\n\nvar debug = require('./debug');\n\nvar jspack = require('../jspack').jspack;\n\nvar AMQPTypes = require('./constants').AMQPTypes;\n\nvar Indicators = require('./constants').Indicators;\n\nvar FrameType = require('./constants').FrameType;\n\nvar definitions = require('./definitions');\n\nvar methodTable = definitions.methodTable;\nvar classes = definitions.classes; // parser\n\nvar MAX_FRAME_BUFFER_DEFAULT = 131072; // 128k, same as rabbitmq (which was\n// copying qpid)\n// An interruptible AMQP parser.\n//\n// type is either 'server' or 'client'\n// version is '0-9-1'.\n//\n// Instances of this class have several callbacks\n// - onMethod(channel, method, args);\n// - onHeartBeat()\n// - onContent(channel, buffer);\n// - onContentHeader(channel, class, weight, properties, size);\n//\n// This class does not subclass EventEmitter, in order to reduce the speed\n// of emitting the callbacks. Since this is an internal class, that should\n// be fine.\n\nvar AMQPParser = module.exports = function AMQPParser(version, type) {\n  this.isClient = type == 'client';\n  this.state = this.isClient ? 'frameHeader' : 'protocolHeader';\n  this.maxFrameBuffer = MAX_FRAME_BUFFER_DEFAULT;\n  if (version != '0-9-1') this.throwError(\"Unsupported protocol version\");\n  var frameHeader = new Buffer(7);\n  frameHeader.used = 0;\n  var frameBuffer, frameType, frameChannel;\n  var self = this;\n\n  function header(data) {\n    var fh = frameHeader;\n    var needed = fh.length - fh.used;\n    data.copy(fh, fh.used, 0, data.length);\n    fh.used += data.length; // sloppy\n\n    if (fh.used >= fh.length) {\n      fh.read = 0;\n      frameType = fh[fh.read++];\n      frameChannel = parseInt(fh, 2);\n      var frameSize = parseInt(fh, 4);\n      fh.used = 0; // for reuse\n\n      if (frameSize > self.maxFrameBuffer) {\n        self.throwError(\"Oversized frame \" + frameSize);\n      }\n\n      frameBuffer = new Buffer(frameSize);\n      frameBuffer.used = 0;\n      return frame(data.slice(needed));\n    } else {\n      // need more!\n      return header;\n    }\n  }\n\n  function frame(data) {\n    var fb = frameBuffer;\n    var needed = fb.length - fb.used;\n    var sourceEnd = fb.length > data.length ? data.length : fb.length;\n    data.copy(fb, fb.used, 0, sourceEnd);\n    fb.used += data.length;\n\n    if (data.length > needed) {\n      return frameEnd(data.slice(needed));\n    } else if (data.length == needed) {\n      return frameEnd;\n    } else {\n      return frame;\n    }\n  }\n\n  function frameEnd(data) {\n    if (data.length > 0) {\n      if (data[0] === Indicators.FRAME_END) {\n        switch (frameType) {\n          case FrameType.METHOD:\n            self._parseMethodFrame(frameChannel, frameBuffer);\n\n            break;\n\n          case FrameType.HEADER:\n            self._parseHeaderFrame(frameChannel, frameBuffer);\n\n            break;\n\n          case FrameType.BODY:\n            if (self.onContent) {\n              self.onContent(frameChannel, frameBuffer);\n            }\n\n            break;\n\n          case FrameType.HEARTBEAT:\n            debug && debug(\"heartbeat\");\n            if (self.onHeartBeat) self.onHeartBeat();\n            break;\n\n          default:\n            self.throwError(\"Unhandled frame type \" + frameType);\n            break;\n        }\n\n        return header(data.slice(1));\n      } else {\n        self.throwError(\"Missing frame end marker\");\n      }\n    } else {\n      return frameEnd;\n    }\n  }\n\n  self.parse = header;\n}; // If there's an error in the parser, call the onError handler or throw\n\n\nAMQPParser.prototype.throwError = function (error) {\n  if (this.onError) this.onError(error);else throw new Error(error);\n}; // Everytime data is recieved on the socket, pass it to this function for\n// parsing.\n\n\nAMQPParser.prototype.execute = function (data) {\n  // This function only deals with dismantling and buffering the frames.\n  // It delegates to other functions for parsing the frame-body.\n  debug && debug('execute: ' + data.toString('hex'));\n  this.parse = this.parse(data);\n};\n/**\n * Set the maximum frame buffer size in bytes. The connection needs to change this\n * if the server responds with a connection tune event where the maxFrameBuffer\n * was changed in the server config.\n *\n * @param maxFrameBuffer the maximum frame buffer size in bytes\n */\n\n\nAMQPParser.prototype.setMaxFrameBuffer = function (maxFrameBuffer) {\n  this.maxFrameBuffer = maxFrameBuffer;\n}; // parse Network Byte Order integers. size can be 1,2,4,8\n\n\nfunction parseInt(buffer, size) {\n  switch (size) {\n    case 1:\n      return buffer[buffer.read++];\n\n    case 2:\n      return (buffer[buffer.read++] << 8) + buffer[buffer.read++];\n\n    case 4:\n      return (buffer[buffer.read++] << 24) + (buffer[buffer.read++] << 16) + (buffer[buffer.read++] << 8) + buffer[buffer.read++];\n\n    case 8:\n      return (buffer[buffer.read++] << 56) + (buffer[buffer.read++] << 48) + (buffer[buffer.read++] << 40) + (buffer[buffer.read++] << 32) + (buffer[buffer.read++] << 24) + (buffer[buffer.read++] << 16) + (buffer[buffer.read++] << 8) + buffer[buffer.read++];\n\n    default:\n      throw new Error(\"cannot parse ints of that size\");\n  }\n}\n\nfunction parseShortString(buffer) {\n  var length = buffer[buffer.read++];\n  var s = buffer.toString('utf8', buffer.read, buffer.read + length);\n  buffer.read += length;\n  return s;\n}\n\nfunction parseLongString(buffer) {\n  var length = parseInt(buffer, 4);\n  var s = buffer.slice(buffer.read, buffer.read + length);\n  buffer.read += length;\n  return s.toString();\n}\n\nfunction parseSignedInteger(buffer) {\n  var int = parseInt(buffer, 4);\n\n  if (int & 0x80000000) {\n    int |= 0xEFFFFFFF;\n    int = -int;\n  }\n\n  return int;\n}\n\nfunction parseValue(buffer) {\n  switch (buffer[buffer.read++]) {\n    case AMQPTypes.STRING:\n      return parseLongString(buffer);\n\n    case AMQPTypes.INTEGER:\n      return parseInt(buffer, 4);\n\n    case AMQPTypes.DECIMAL:\n      var dec = parseInt(buffer, 1);\n      var num = parseInt(buffer, 4);\n      return num / (dec * 10);\n\n    case AMQPTypes._64BIT_FLOAT:\n      var b = [];\n\n      for (var i = 0; i < 8; ++i) b[i] = buffer[buffer.read++];\n\n      return new jspack(true).Unpack('d', b);\n\n    case AMQPTypes._32BIT_FLOAT:\n      var b = [];\n\n      for (var i = 0; i < 4; ++i) b[i] = buffer[buffer.read++];\n\n      return new jspack(true).Unpack('f', b);\n\n    case AMQPTypes.TIME:\n      var int = parseInt(buffer, 8);\n      return new Date().setTime(int * 1000);\n\n    case AMQPTypes.HASH:\n      return parseTable(buffer);\n\n    case AMQPTypes.SIGNED_64BIT:\n      return parseInt(buffer, 8);\n\n    case AMQPTypes.SIGNED_8BIT:\n      return parseInt(buffer, 1);\n\n    case AMQPTypes.BOOLEAN:\n      return parseInt(buffer, 1) > 0;\n\n    case AMQPTypes.BYTE_ARRAY:\n      var len = parseInt(buffer, 4);\n      var buf = new Buffer(len);\n      buffer.copy(buf, 0, buffer.read, buffer.read + len);\n      buffer.read += len;\n      return buf;\n\n    case AMQPTypes.ARRAY:\n      var len = parseInt(buffer, 4);\n      var end = buffer.read + len;\n      var arr = [];\n\n      while (buffer.read < end) {\n        arr.push(parseValue(buffer));\n      }\n\n      return arr;\n\n    case AMQPTypes.VOID:\n      return null;\n\n    default:\n      throw new Error(\"Unknown field value type \" + buffer[buffer.read - 1]);\n  }\n}\n\nfunction parseTable(buffer) {\n  var length = buffer.read + parseInt(buffer, 4);\n  var table = {};\n\n  while (buffer.read < length) {\n    table[parseShortString(buffer)] = parseValue(buffer);\n  }\n\n  return table;\n}\n\nfunction parseFields(buffer, fields) {\n  var args = {};\n  var bitIndex = 0;\n  var value;\n\n  for (var i = 0; i < fields.length; i++) {\n    var field = fields[i]; //debug && debug(\"parsing field \" + field.name + \" of type \" + field.domain);\n\n    switch (field.domain) {\n      case 'bit':\n        // 8 bits can be packed into one octet.\n        // XXX check if bitIndex greater than 7?\n        value = buffer[buffer.read] & 1 << bitIndex ? true : false;\n\n        if (fields[i + 1] && fields[i + 1].domain == 'bit') {\n          bitIndex++;\n        } else {\n          bitIndex = 0;\n          buffer.read++;\n        }\n\n        break;\n\n      case 'octet':\n        value = buffer[buffer.read++];\n        break;\n\n      case 'short':\n        value = parseInt(buffer, 2);\n        break;\n\n      case 'long':\n        value = parseInt(buffer, 4);\n        break;\n      // In a previous version this shared code with 'longlong', which caused problems when passed Date \n      // integers. Nobody expects to pass a Buffer here, 53 bits is still 28 million years after 1970, we'll be fine.\n\n      case 'timestamp':\n        value = parseInt(buffer, 8);\n        break;\n      // JS doesn't support 64-bit Numbers, so we expect if you're using 'longlong' that you've\n      // used a Buffer instead\n\n      case 'longlong':\n        value = new Buffer(8);\n\n        for (var j = 0; j < 8; j++) {\n          value[j] = buffer[buffer.read++];\n        }\n\n        break;\n\n      case 'shortstr':\n        value = parseShortString(buffer);\n        break;\n\n      case 'longstr':\n        value = parseLongString(buffer);\n        break;\n\n      case 'table':\n        value = parseTable(buffer);\n        break;\n\n      default:\n        throw new Error(\"Unhandled parameter type \" + field.domain);\n    } //debug && debug(\"got \" + value);\n\n\n    args[field.name] = value;\n  }\n\n  return args;\n}\n\nAMQPParser.prototype._parseMethodFrame = function (channel, buffer) {\n  buffer.read = 0;\n  var classId = parseInt(buffer, 2),\n      methodId = parseInt(buffer, 2); // Make sure that this is a method that we understand.\n\n  if (!methodTable[classId] || !methodTable[classId][methodId]) {\n    this.throwError(\"Received unknown [classId, methodId] pair [\" + classId + \", \" + methodId + \"]\");\n  }\n\n  var method = methodTable[classId][methodId];\n  if (!method) this.throwError(\"bad method?\");\n  var args = parseFields(buffer, method.fields);\n\n  if (this.onMethod) {\n    debug && debug(\"Executing method\", channel, method, args);\n    this.onMethod(channel, method, args);\n  }\n};\n\nAMQPParser.prototype._parseHeaderFrame = function (channel, buffer) {\n  buffer.read = 0;\n  var classIndex = parseInt(buffer, 2);\n  var weight = parseInt(buffer, 2);\n  var size = parseInt(buffer, 8);\n  var classInfo = classes[classIndex];\n\n  if (classInfo.fields.length > 15) {\n    this.throwError(\"TODO: support more than 15 properties\");\n  }\n\n  var propertyFlags = parseInt(buffer, 2);\n  var fields = [];\n\n  for (var i = 0; i < classInfo.fields.length; i++) {\n    var field = classInfo.fields[i]; // groan.\n\n    if (propertyFlags & 1 << 15 - i) fields.push(field);\n  }\n\n  var properties = parseFields(buffer, fields);\n\n  if (this.onContentHeader) {\n    this.onContentHeader(channel, classInfo, weight, properties, size);\n  }\n};","map":{"version":3,"sources":["/Users/alexyang/Desktop/todolist/Traffic-Generator/node_modules/amqp/lib/parser.js"],"names":["events","require","util","net","tls","fs","debug","jspack","AMQPTypes","Indicators","FrameType","definitions","methodTable","classes","MAX_FRAME_BUFFER_DEFAULT","AMQPParser","module","exports","version","type","isClient","state","maxFrameBuffer","throwError","frameHeader","Buffer","used","frameBuffer","frameType","frameChannel","self","header","data","fh","needed","length","copy","read","parseInt","frameSize","frame","slice","fb","sourceEnd","frameEnd","FRAME_END","METHOD","_parseMethodFrame","HEADER","_parseHeaderFrame","BODY","onContent","HEARTBEAT","onHeartBeat","parse","prototype","error","onError","Error","execute","toString","setMaxFrameBuffer","buffer","size","parseShortString","s","parseLongString","parseSignedInteger","int","parseValue","STRING","INTEGER","DECIMAL","dec","num","_64BIT_FLOAT","b","i","Unpack","_32BIT_FLOAT","TIME","Date","setTime","HASH","parseTable","SIGNED_64BIT","SIGNED_8BIT","BOOLEAN","BYTE_ARRAY","len","buf","ARRAY","end","arr","push","VOID","table","parseFields","fields","args","bitIndex","value","field","domain","j","name","channel","classId","methodId","method","onMethod","classIndex","weight","classInfo","propertyFlags","properties","onContentHeader"],"mappings":"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","sourcesContent":["'use strict';\n\nvar events = require('events');\nvar util = require('util');\nvar net = require('net');\nvar tls = require('tls');\nvar fs = require('fs');\nvar debug = require('./debug');\nvar jspack = require('../jspack').jspack;\nvar AMQPTypes = require('./constants').AMQPTypes;\nvar Indicators = require('./constants').Indicators;\nvar FrameType = require('./constants').FrameType;\nvar definitions = require('./definitions');\nvar methodTable = definitions.methodTable;\nvar classes = definitions.classes;\n\n// parser\n\nvar MAX_FRAME_BUFFER_DEFAULT = 131072; // 128k, same as rabbitmq (which was\n                             // copying qpid)\n\n// An interruptible AMQP parser.\n//\n// type is either 'server' or 'client'\n// version is '0-9-1'.\n//\n// Instances of this class have several callbacks\n// - onMethod(channel, method, args);\n// - onHeartBeat()\n// - onContent(channel, buffer);\n// - onContentHeader(channel, class, weight, properties, size);\n//\n// This class does not subclass EventEmitter, in order to reduce the speed\n// of emitting the callbacks. Since this is an internal class, that should\n// be fine.\nvar AMQPParser = module.exports = function AMQPParser (version, type) {\n  this.isClient = (type == 'client');\n  this.state = this.isClient ? 'frameHeader' : 'protocolHeader';\n  this.maxFrameBuffer = MAX_FRAME_BUFFER_DEFAULT;\n\n  if (version != '0-9-1') this.throwError(\"Unsupported protocol version\");\n\n  var frameHeader = new Buffer(7);\n  frameHeader.used = 0;\n  var frameBuffer, frameType, frameChannel;\n\n  var self = this;\n\n  function header(data) {\n    var fh = frameHeader;\n    var needed = fh.length - fh.used;\n    data.copy(fh, fh.used, 0, data.length);\n    fh.used += data.length; // sloppy\n    if (fh.used >= fh.length) {\n      fh.read = 0;\n      frameType = fh[fh.read++];\n      frameChannel = parseInt(fh, 2);\n      var frameSize = parseInt(fh, 4);\n      fh.used = 0; // for reuse\n      if (frameSize > self.maxFrameBuffer) {\n        self.throwError(\"Oversized frame \" + frameSize);\n      }\n      frameBuffer = new Buffer(frameSize);\n      frameBuffer.used = 0;\n      return frame(data.slice(needed));\n    }\n    else { // need more!\n      return header;\n    }\n  }\n\n  function frame(data) {\n    var fb = frameBuffer;\n    var needed = fb.length - fb.used;\n    var sourceEnd = (fb.length > data.length) ? data.length : fb.length;\n    data.copy(fb, fb.used, 0, sourceEnd);\n    fb.used += data.length;\n    if (data.length > needed) {\n      return frameEnd(data.slice(needed));\n    }\n    else if (data.length == needed) {\n      return frameEnd;\n    }\n    else {\n      return frame;\n    }\n  }\n\n  function frameEnd(data) {\n    if (data.length > 0) {\n      if (data[0] === Indicators.FRAME_END) {\n        switch (frameType) {\n        case FrameType.METHOD:\n          self._parseMethodFrame(frameChannel, frameBuffer);\n          break;\n        case FrameType.HEADER:\n          self._parseHeaderFrame(frameChannel, frameBuffer);\n          break;\n        case FrameType.BODY:\n          if (self.onContent) {\n            self.onContent(frameChannel, frameBuffer);\n          }\n          break;\n        case FrameType.HEARTBEAT:\n          debug && debug(\"heartbeat\");\n          if (self.onHeartBeat) self.onHeartBeat();\n          break;\n        default:\n          self.throwError(\"Unhandled frame type \" + frameType);\n          break;\n        }\n        return header(data.slice(1));\n      }\n      else {\n        self.throwError(\"Missing frame end marker\");\n      }\n    }\n    else {\n      return frameEnd;\n    }\n  }\n\n  self.parse = header;\n}\n\n// If there's an error in the parser, call the onError handler or throw\nAMQPParser.prototype.throwError = function (error) {\n  if (this.onError) this.onError(error);\n  else throw new Error(error);\n};\n\n// Everytime data is recieved on the socket, pass it to this function for\n// parsing.\nAMQPParser.prototype.execute = function (data) {\n  // This function only deals with dismantling and buffering the frames.\n  // It delegates to other functions for parsing the frame-body.\n  debug && debug('execute: ' + data.toString('hex'));\n  this.parse = this.parse(data);\n};\n\n/**\n * Set the maximum frame buffer size in bytes. The connection needs to change this\n * if the server responds with a connection tune event where the maxFrameBuffer\n * was changed in the server config.\n *\n * @param maxFrameBuffer the maximum frame buffer size in bytes\n */\nAMQPParser.prototype.setMaxFrameBuffer = function(maxFrameBuffer) {\n  this.maxFrameBuffer = maxFrameBuffer;\n};\n\n// parse Network Byte Order integers. size can be 1,2,4,8\nfunction parseInt (buffer, size) {\n  switch (size) {\n    case 1:\n      return buffer[buffer.read++];\n\n    case 2:\n      return (buffer[buffer.read++] << 8) + buffer[buffer.read++];\n\n    case 4:\n      return (buffer[buffer.read++] << 24) + (buffer[buffer.read++] << 16) +\n             (buffer[buffer.read++] << 8)  + buffer[buffer.read++];\n\n    case 8:\n      return (buffer[buffer.read++] << 56) + (buffer[buffer.read++] << 48) +\n             (buffer[buffer.read++] << 40) + (buffer[buffer.read++] << 32) +\n             (buffer[buffer.read++] << 24) + (buffer[buffer.read++] << 16) +\n             (buffer[buffer.read++] << 8)  + buffer[buffer.read++];\n\n    default:\n      throw new Error(\"cannot parse ints of that size\");\n  }\n}\n\n\nfunction parseShortString (buffer) {\n  var length = buffer[buffer.read++];\n  var s = buffer.toString('utf8', buffer.read, buffer.read+length);\n  buffer.read += length;\n  return s;\n}\n\n\nfunction parseLongString (buffer) {\n  var length = parseInt(buffer, 4);\n  var s = buffer.slice(buffer.read, buffer.read + length);\n  buffer.read += length;\n  return s.toString();\n}\n\n\nfunction parseSignedInteger (buffer) {\n  var int = parseInt(buffer, 4);\n  if (int & 0x80000000) {\n    int |= 0xEFFFFFFF;\n    int = -int;\n  }\n  return int;\n}\n\nfunction parseValue (buffer) {\n  switch (buffer[buffer.read++]) {\n    case AMQPTypes.STRING:\n      return parseLongString(buffer);\n\n    case AMQPTypes.INTEGER:\n      return parseInt(buffer, 4);\n\n    case AMQPTypes.DECIMAL:\n      var dec = parseInt(buffer, 1);\n      var num = parseInt(buffer, 4);\n      return num / (dec * 10);\n\n    case AMQPTypes._64BIT_FLOAT:\n      var b = [];\n      for (var i = 0; i < 8; ++i)\n        b[i] = buffer[buffer.read++];\n\n      return (new jspack(true)).Unpack('d', b);\n\n    case AMQPTypes._32BIT_FLOAT:\n      var b = [];\n      for (var i = 0; i < 4; ++i)\n        b[i] = buffer[buffer.read++];\n\n      return (new jspack(true)).Unpack('f', b);\n\n    case AMQPTypes.TIME:\n      var int = parseInt(buffer, 8);\n      return (new Date()).setTime(int * 1000);\n\n    case AMQPTypes.HASH:\n      return parseTable(buffer);\n\n    case AMQPTypes.SIGNED_64BIT:\n      return parseInt(buffer, 8);\n\n    case AMQPTypes.SIGNED_8BIT:\n      return parseInt(buffer, 1);\n\n    case AMQPTypes.BOOLEAN:\n      return (parseInt(buffer, 1) > 0);\n\n    case AMQPTypes.BYTE_ARRAY:\n      var len = parseInt(buffer, 4);\n      var buf = new Buffer(len);\n      buffer.copy(buf, 0, buffer.read, buffer.read + len);\n      buffer.read += len;\n      return buf;\n\n    case AMQPTypes.ARRAY:\n      var len = parseInt(buffer, 4);\n      var end = buffer.read + len;\n      var arr = [];\n\n      while (buffer.read < end) {\n        arr.push(parseValue(buffer));\n      }\n\n      return arr;\n\n    case AMQPTypes.VOID:\n      return null;\n\n    default:\n      throw new Error(\"Unknown field value type \" + buffer[buffer.read-1]);\n  }\n}\n\nfunction parseTable (buffer) {\n  var length = buffer.read + parseInt(buffer, 4);\n  var table = {};\n\n  while (buffer.read < length) {\n    table[parseShortString(buffer)] = parseValue(buffer);\n  }\n\n  return table;\n}\n\nfunction parseFields (buffer, fields) {\n  var args = {};\n  var bitIndex = 0;\n  var value;\n\n  for (var i = 0; i < fields.length; i++) {\n    var field = fields[i];\n\n    //debug && debug(\"parsing field \" + field.name + \" of type \" + field.domain);\n\n    switch (field.domain) {\n      case 'bit':\n        // 8 bits can be packed into one octet.\n\n        // XXX check if bitIndex greater than 7?\n\n        value = (buffer[buffer.read] & (1 << bitIndex)) ? true : false;\n\n        if (fields[i+1] && fields[i+1].domain == 'bit') {\n          bitIndex++;\n        } else {\n          bitIndex = 0;\n          buffer.read++;\n        }\n        break;\n\n      case 'octet':\n        value = buffer[buffer.read++];\n        break;\n\n      case 'short':\n        value = parseInt(buffer, 2);\n        break;\n\n      case 'long':\n        value = parseInt(buffer, 4);\n        break;\n\n      // In a previous version this shared code with 'longlong', which caused problems when passed Date \n      // integers. Nobody expects to pass a Buffer here, 53 bits is still 28 million years after 1970, we'll be fine.\n      case 'timestamp':\n        value = parseInt(buffer, 8);\n        break;\n\n      // JS doesn't support 64-bit Numbers, so we expect if you're using 'longlong' that you've\n      // used a Buffer instead\n      case 'longlong':\n        value = new Buffer(8);\n        for (var j = 0; j < 8; j++) {\n          value[j] = buffer[buffer.read++];\n        }\n        break;\n\n      case 'shortstr':\n        value = parseShortString(buffer);\n        break;\n\n      case 'longstr':\n        value = parseLongString(buffer);\n        break;\n\n      case 'table':\n        value = parseTable(buffer);\n        break;\n\n      default:\n        throw new Error(\"Unhandled parameter type \" + field.domain);\n    }\n    //debug && debug(\"got \" + value);\n    args[field.name] = value;\n  }\n\n  return args;\n}\n\n\nAMQPParser.prototype._parseMethodFrame = function (channel, buffer) {\n  buffer.read = 0;\n  var classId = parseInt(buffer, 2),\n     methodId = parseInt(buffer, 2);\n\n  // Make sure that this is a method that we understand.\n  if (!methodTable[classId] || !methodTable[classId][methodId]) {\n    this.throwError(\"Received unknown [classId, methodId] pair [\" +\n               classId + \", \" + methodId + \"]\");\n  }\n\n  var method = methodTable[classId][methodId];\n\n  if (!method) this.throwError(\"bad method?\");\n\n  var args = parseFields(buffer, method.fields);\n\n  if (this.onMethod) {\n    debug && debug(\"Executing method\", channel, method, args);\n    this.onMethod(channel, method, args);\n  }\n};\n\n\nAMQPParser.prototype._parseHeaderFrame = function (channel, buffer) {\n  buffer.read = 0;\n\n  var classIndex = parseInt(buffer, 2);\n  var weight = parseInt(buffer, 2);\n  var size = parseInt(buffer, 8);\n\n  var classInfo = classes[classIndex];\n\n  if (classInfo.fields.length > 15) {\n    this.throwError(\"TODO: support more than 15 properties\");\n  }\n\n  var propertyFlags = parseInt(buffer, 2);\n\n  var fields = [];\n  for (var i = 0; i < classInfo.fields.length; i++) {\n    var field = classInfo.fields[i];\n    // groan.\n    if (propertyFlags & (1 << (15-i))) fields.push(field);\n  }\n\n  var properties = parseFields(buffer, fields);\n\n  if (this.onContentHeader) {\n    this.onContentHeader(channel, classInfo, weight, properties, size);\n  }\n};\n"]},"metadata":{},"sourceType":"script"}