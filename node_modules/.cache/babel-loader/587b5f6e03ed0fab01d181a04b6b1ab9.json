{"ast":null,"code":"'use strict';\n\nvar util = require('util');\n\nvar fs = require('fs');\n\nvar StringDecoder = require('string_decoder').StringDecoder;\n\nvar _ = require('lodash');\n\nvar Channel = require('./channel');\n\nvar Exchange = require('./exchange');\n\nvar Message = require('./message');\n\nvar debug = require('./debug');\n\nvar definitions = require('./definitions');\n\nvar methods = definitions.methods;\nvar classes = definitions.classes;\n\nvar Queue = module.exports = function Queue(connection, channel, name, options, callback) {\n  Channel.call(this, connection, channel);\n  var self = this;\n  this.name = name;\n  this._bindings = {};\n  this.consumerTagListeners = {};\n  this.consumerTagOptions = {}; // route messages to subscribers based on consumerTag\n\n  this.on('rawMessage', function (message) {\n    if (message.consumerTag && self.consumerTagListeners[message.consumerTag]) {\n      self.consumerTagListeners[message.consumerTag](message);\n    }\n  });\n  this.options = {\n    autoDelete: true,\n    closeChannelOnUnsubscribe: false\n  };\n\n  _.assignIn(this.options, options || {});\n\n  this._openCallback = callback;\n};\n\nutil.inherits(Queue, Channel);\n\nQueue.prototype.subscribeRaw = function (options, messageListener, oldConsumerTag) {\n  var self = this; // multiple method signatures\n\n  if (typeof options === \"function\") {\n    oldConsumerTag = messageListener;\n    messageListener = options;\n    options = {};\n  }\n\n  var consumerTag;\n\n  if (options.consumerTag !== undefined) {\n    consumerTag = options.consumerTag + '-' + Math.random();\n  } else {\n    consumerTag = 'node-amqp-' + process.pid + '-' + Math.random();\n  }\n\n  this.consumerTagListeners[consumerTag] = messageListener;\n  options = options || {};\n  options['state'] = 'opening';\n  this.consumerTagOptions[consumerTag] = options;\n\n  if (options.prefetchCount !== undefined) {\n    self.connection._sendMethod(self.channel, methods.basicQos, {\n      reserved1: 0,\n      prefetchSize: 0,\n      prefetchCount: options.prefetchCount,\n      global: false\n    });\n  } // If this is a reconnection, we should probably tell folks their tag has changed\n\n\n  if (oldConsumerTag) {\n    debug && debug('Existing consumer tag changed', util.inspect({\n      oldConsumerTag: oldConsumerTag,\n      consumerTag: consumerTag\n    }));\n    self.connection.emit('tag.change', {\n      oldConsumerTag: oldConsumerTag,\n      consumerTag: consumerTag\n    });\n  }\n\n  return this._taskPush(methods.basicConsumeOk, function () {\n    self.connection._sendMethod(self.channel, methods.basicConsume, {\n      reserved1: 0,\n      queue: self.name,\n      consumerTag: consumerTag,\n      noLocal: !!options.noLocal,\n      noAck: !!options.noAck,\n      exclusive: !!options.exclusive,\n      noWait: false,\n      \"arguments\": {}\n    });\n\n    self.consumerTagOptions[consumerTag]['state'] = 'open';\n  });\n};\n\nQueue.prototype.unsubscribe = function (consumerTag) {\n  var self = this;\n  return this._taskPush(methods.basicCancelOk, function () {\n    self.connection._sendMethod(self.channel, methods.basicCancel, {\n      reserved1: 0,\n      consumerTag: consumerTag,\n      noWait: false\n    });\n  }).addCallback(function () {\n    if (self.options.closeChannelOnUnsubscribe) {\n      self.close();\n    }\n\n    delete self.consumerTagListeners[consumerTag];\n    delete self.consumerTagOptions[consumerTag];\n  });\n};\n\nQueue.prototype.subscribe = function (options, messageListener) {\n  var self = this; // Optional options\n\n  if (typeof options === \"function\") {\n    messageListener = options;\n    options = {};\n  }\n\n  options = _.defaults(options || {}, {\n    ack: false,\n    prefetchCount: 1,\n    routingKeyInPayload: self.connection.options.routingKeyInPayload,\n    deliveryTagInPayload: self.connection.options.deliveryTagInPayload\n  }); // basic consume\n\n  var rawOptions = {\n    noAck: !options.ack,\n    exclusive: options.exclusive\n  };\n\n  if (options.ack) {\n    rawOptions['prefetchCount'] = options.prefetchCount;\n  }\n\n  if (options.consumerTag) {\n    rawOptions['consumerTag'] = options.consumerTag;\n  }\n\n  return this.subscribeRaw(rawOptions, function (m) {\n    var contentType = m.contentType;\n    var decoder = new StringDecoder('utf8');\n\n    if (contentType == null && m.headers && m.headers.properties) {\n      contentType = m.headers.properties.content_type;\n    }\n\n    var isJSON = contentType == 'text/json' || contentType == 'application/json';\n    var buffer;\n\n    if (isJSON) {\n      buffer = \"\";\n    } else {\n      buffer = new Buffer(m.size);\n      buffer.used = 0;\n    }\n\n    self._lastMessage = m;\n    m.addListener('data', function (d) {\n      if (isJSON) {\n        buffer += decoder.write(d);\n      } else {\n        d.copy(buffer, buffer.used);\n        buffer.used += d.length;\n      }\n    });\n    m.addListener('end', function () {\n      var json,\n          deliveryInfo = {},\n          msgProperties = classes[60].fields,\n          i,\n          l;\n\n      if (isJSON) {\n        decoder.end();\n\n        try {\n          json = JSON.parse(buffer);\n        } catch (e) {\n          json = null;\n          deliveryInfo.parseError = e;\n          deliveryInfo.rawData = buffer;\n        }\n      } else {\n        json = {\n          data: buffer,\n          contentType: m.contentType\n        };\n      }\n\n      for (i = 0, l = msgProperties.length; i < l; i++) {\n        if (m[msgProperties[i].name]) {\n          deliveryInfo[msgProperties[i].name] = m[msgProperties[i].name];\n        }\n      }\n\n      deliveryInfo.queue = m.queue ? m.queue.name : null;\n      deliveryInfo.deliveryTag = m.deliveryTag;\n      deliveryInfo.redelivered = m.redelivered;\n      deliveryInfo.exchange = m.exchange;\n      deliveryInfo.routingKey = m.routingKey;\n      deliveryInfo.consumerTag = m.consumerTag;\n      if (options.routingKeyInPayload) json._routingKey = m.routingKey;\n      if (options.deliveryTagInPayload) json._deliveryTag = m.deliveryTag;\n      var headers = {};\n\n      for (i in this.headers) {\n        if (this.headers.hasOwnProperty(i)) {\n          if (this.headers[i] instanceof Buffer) {\n            headers[i] = this.headers[i].toString();\n          } else {\n            headers[i] = this.headers[i];\n          }\n        }\n      }\n\n      if (messageListener) messageListener(json, headers, deliveryInfo, m);\n      self.emit('message', json, headers, deliveryInfo, m);\n    });\n  });\n};\n\nQueue.prototype.subscribeJSON = Queue.prototype.subscribe;\n/* Acknowledges the last message */\n\nQueue.prototype.shift = function (reject, requeue) {\n  if (this._lastMessage) {\n    if (reject) {\n      this._lastMessage.reject(requeue ? true : false);\n    } else {\n      this._lastMessage.acknowledge();\n    }\n\n    this._lastMessage = null;\n  }\n};\n\nQueue.prototype.bind = function (exchange, routingKey, callback) {\n  var self = this; // The first argument, exchange is optional.\n  // If not supplied the connection will use the 'amq.topic'\n  // exchange.\n\n  if (routingKey === undefined || _.isFunction(routingKey)) {\n    callback = routingKey;\n    routingKey = exchange;\n    exchange = 'amq.topic';\n  }\n\n  if (_.isFunction(callback)) this._bindCallback = callback;\n  var exchangeName = exchange instanceof Exchange ? exchange.name : exchange;\n\n  if (exchangeName in self.connection.exchanges) {\n    this.exchange = self.connection.exchanges[exchangeName];\n    this.exchange.binds++;\n  } // Record this binding so we can restore it upon reconnect.\n\n\n  if (!this._bindings[exchangeName]) {\n    this._bindings[exchangeName] = {};\n  }\n\n  if (!this._bindings[exchangeName][routingKey]) {\n    this._bindings[exchangeName][routingKey] = 0;\n  }\n\n  this._bindings[exchangeName][routingKey]++;\n\n  self.connection._sendMethod(self.channel, methods.queueBind, {\n    reserved1: 0,\n    queue: self.name,\n    exchange: exchangeName,\n    routingKey: routingKey,\n    noWait: false,\n    \"arguments\": {}\n  });\n};\n\nQueue.prototype.unbind = function (exchange, routingKey) {\n  var self = this; // The first argument, exchange is optional.\n  // If not supplied the connection will use the default 'amq.topic'\n  // exchange.\n\n  if (routingKey === undefined) {\n    routingKey = exchange;\n    exchange = 'amq.topic';\n  }\n\n  var exchangeName = exchange instanceof Exchange ? exchange.name : exchange;\n\n  if (this._bindings[exchangeName]) {\n    // Decrement binding count.\n    this._bindings[exchangeName][routingKey]--;\n\n    if (!this._bindings[exchangeName][routingKey]) {\n      delete this._bindings[exchangeName][routingKey];\n    } // If there are no more bindings to this exchange, delete the key for the exchange.\n\n\n    if (!_.keys(this._bindings[exchangeName]).length) {\n      delete this._bindings[exchangeName];\n    }\n  }\n\n  return this._taskPush(methods.queueUnbindOk, function () {\n    self.connection._sendMethod(self.channel, methods.queueUnbind, {\n      reserved1: 0,\n      queue: self.name,\n      exchange: exchangeName,\n      routingKey: routingKey,\n      noWait: false,\n      \"arguments\": {}\n    });\n  });\n};\n\nQueue.prototype.bind_headers = function ()\n/* [exchange,] matchingPairs */\n{\n  var self = this; // The first argument, exchange is optional.\n  // If not supplied the connection will use the default 'amq.headers'\n  // exchange.\n\n  var exchange, matchingPairs;\n\n  if (arguments.length == 2) {\n    exchange = arguments[0];\n    matchingPairs = arguments[1];\n  } else {\n    exchange = 'amq.headers';\n    matchingPairs = arguments[0];\n  }\n\n  return this._taskPush(methods.queueBindOk, function () {\n    var exchangeName = exchange instanceof Exchange ? exchange.name : exchange;\n\n    self.connection._sendMethod(self.channel, methods.queueBind, {\n      reserved1: 0,\n      queue: self.name,\n      exchange: exchangeName,\n      routingKey: '',\n      noWait: false,\n      \"arguments\": matchingPairs\n    });\n  });\n};\n\nQueue.prototype.unbind_headers = function ()\n/* [exchange,] matchingPairs */\n{\n  var self = this; // The first argument, exchange is optional.\n  // If not supplied the connection will use the default 'amq.topic'\n  // exchange.\n\n  var exchange, matchingPairs;\n\n  if (arguments.length === 2) {\n    exchange = arguments[0];\n    matchingPairs = arguments[1];\n  } else {\n    exchange = 'amq.headers';\n    matchingPairs = arguments[0];\n  }\n\n  return this._taskPush(methods.queueUnbindOk, function () {\n    var exchangeName = exchange instanceof Exchange ? exchange.name : exchange;\n\n    self.connection._sendMethod(self.channel, methods.queueUnbind, {\n      reserved1: 0,\n      queue: self.name,\n      exchange: exchangeName,\n      routingKey: '',\n      noWait: false,\n      \"arguments\": matchingPairs\n    });\n  });\n};\n\nQueue.prototype.destroy = function (options) {\n  var self = this;\n  options = options || {};\n  return this._taskPush(methods.queueDeleteOk, function () {\n    self.connection.queueClosed(self.name);\n\n    if ('exchange' in self) {\n      self.exchange.binds--;\n    }\n\n    self.connection._sendMethod(self.channel, methods.queueDelete, {\n      reserved1: 0,\n      queue: self.name,\n      ifUnused: options.ifUnused ? true : false,\n      ifEmpty: options.ifEmpty ? true : false,\n      noWait: false,\n      \"arguments\": {}\n    });\n  });\n};\n\nQueue.prototype.purge = function () {\n  var self = this;\n  return this._taskPush(methods.queuePurgeOk, function () {\n    self.connection._sendMethod(self.channel, methods.queuePurge, {\n      reserved1: 0,\n      queue: self.name,\n      noWait: false\n    });\n  });\n};\n\nQueue.prototype._onMethod = function (channel, method, args) {\n  var self = this;\n  this.emit(method.name, args);\n  if (this._handleTaskReply.apply(this, arguments)) return;\n\n  switch (method) {\n    case methods.channelOpenOk:\n      if (this.options.noDeclare) {\n        this.state = 'open';\n\n        if (this._openCallback) {\n          this._openCallback(this);\n\n          this._openCallback = null;\n        }\n\n        this.emit('open');\n      } else {\n        if (this.name.indexOf('amq.') == 0) {\n          this.name = '';\n        }\n\n        this.connection._sendMethod(channel, methods.queueDeclare, {\n          reserved1: 0,\n          queue: this.name,\n          passive: !!this.options.passive,\n          durable: !!this.options.durable,\n          exclusive: !!this.options.exclusive,\n          autoDelete: !!this.options.autoDelete,\n          noWait: false,\n          \"arguments\": this.options.arguments || {}\n        });\n\n        this.state = \"declare queue\";\n      }\n\n      break;\n\n    case methods.queueDeclareOk:\n      this.state = 'open';\n      this.name = args.queue;\n      this.connection.queues[this.name] = this; // Rebind to previously bound exchanges, if present.\n      // Important this is called *before* openCallback, otherwise bindings will happen twice.\n      // Run test-purge to make sure you got this right\n\n      _.forEach(this._bindings, function (exchange, exchangeName) {\n        _.forEach(exchange, function (count, routingKey) {\n          self.bind(exchangeName, routingKey);\n        });\n      }); // Call opening callback (passed in function)\n      // FIXME use eventemitter - maybe we call a namespaced event here\n\n\n      if (this._openCallback) {\n        this._openCallback(this, args.messageCount, args.consumerCount);\n\n        this._openCallback = null;\n      } // TODO this is legacy interface, remove me\n\n\n      this.emit('open', args.queue, args.messageCount, args.consumerCount); // If this is a reconnect, we must re-subscribe our queue listeners.\n\n      var consumerTags = Object.keys(this.consumerTagListeners);\n\n      for (var index in consumerTags) {\n        if (consumerTags.hasOwnProperty(index)) {\n          if (this.consumerTagOptions[consumerTags[index]]['state'] === 'closed') {\n            this.subscribeRaw(this.consumerTagOptions[consumerTags[index]], this.consumerTagListeners[consumerTags[index]], consumerTags[index]); // Having called subscribeRaw, we are now a new consumer with a new consumerTag.\n\n            delete this.consumerTagListeners[consumerTags[index]];\n            delete this.consumerTagOptions[consumerTags[index]];\n          }\n        }\n      }\n\n      break;\n\n    case methods.basicConsumeOk:\n      debug && debug('basicConsumeOk', util.inspect(args, null));\n      break;\n\n    case methods.queueBindOk:\n      if (this._bindCallback) {\n        // setting this._bindCallback to null before calling the callback allows for a subsequent bind within the callback\n        // FIXME use eventemitter\n        var cb = this._bindCallback;\n        this._bindCallback = null;\n        cb(this);\n      }\n\n      break;\n\n    case methods.queueUnbindOk:\n      break;\n\n    case methods.basicQosOk:\n      break;\n\n    case methods.confirmSelectOk:\n      this._sequence = 1;\n      this.confirm = true;\n      break;\n\n    case methods.channelClose:\n      this.state = \"closed\";\n      this.closeOK();\n      this.connection.queueClosed(this.name);\n      var e = new Error(args.replyText);\n      e.code = args.replyCode;\n      this.emit('error', e);\n      this.emit('close');\n      break;\n\n    case methods.channelCloseOk:\n      this.connection.queueClosed(this.name);\n      this.emit('close');\n      break;\n\n    case methods.basicDeliver:\n      this.currentMessage = new Message(this, args);\n      break;\n\n    case methods.queueDeleteOk:\n      break;\n\n    case methods.basicCancel:\n      this.close(\"Closed due to basicCancel received on consumer (\" + args.consumerTag + \")\");\n      break;\n\n    default:\n      throw new Error(\"Uncaught method '\" + method.name + \"' with args \" + JSON.stringify(args) + \"; tasks = \" + JSON.stringify(this._tasks));\n  }\n\n  this._tasksFlush();\n};\n\nQueue.prototype._onContentHeader = function (channel, classInfo, weight, properties, size) {\n  _.assignIn(this.currentMessage, properties);\n\n  this.currentMessage.read = 0;\n  this.currentMessage.size = size;\n  this.emit('rawMessage', this.currentMessage);\n\n  if (size === 0) {\n    // If the message has no body, directly emit 'end'\n    this.currentMessage.emit('end');\n  }\n};\n\nQueue.prototype._onContent = function (channel, data) {\n  this.currentMessage.read += data.length;\n  this.currentMessage.emit('data', data);\n\n  if (this.currentMessage.read == this.currentMessage.size) {\n    this.currentMessage.emit('end');\n  }\n};\n\nQueue.prototype.flow = function (active) {\n  var self = this;\n  return this._taskPush(methods.channelFlowOk, function () {\n    self.connection._sendMethod(self.channel, methods.channelFlow, {\n      'active': active\n    });\n  });\n};","map":{"version":3,"sources":["/Users/alexyang/Desktop/todolist/Traffic-Generator/node_modules/amqp/lib/queue.js"],"names":["util","require","fs","StringDecoder","_","Channel","Exchange","Message","debug","definitions","methods","classes","Queue","module","exports","connection","channel","name","options","callback","call","self","_bindings","consumerTagListeners","consumerTagOptions","on","message","consumerTag","autoDelete","closeChannelOnUnsubscribe","assignIn","_openCallback","inherits","prototype","subscribeRaw","messageListener","oldConsumerTag","undefined","Math","random","process","pid","prefetchCount","_sendMethod","basicQos","reserved1","prefetchSize","global","inspect","emit","_taskPush","basicConsumeOk","basicConsume","queue","noLocal","noAck","exclusive","noWait","unsubscribe","basicCancelOk","basicCancel","addCallback","close","subscribe","defaults","ack","routingKeyInPayload","deliveryTagInPayload","rawOptions","m","contentType","decoder","headers","properties","content_type","isJSON","buffer","Buffer","size","used","_lastMessage","addListener","d","write","copy","length","json","deliveryInfo","msgProperties","fields","i","l","end","JSON","parse","e","parseError","rawData","data","deliveryTag","redelivered","exchange","routingKey","_routingKey","_deliveryTag","hasOwnProperty","toString","subscribeJSON","shift","reject","requeue","acknowledge","bind","isFunction","_bindCallback","exchangeName","exchanges","binds","queueBind","unbind","keys","queueUnbindOk","queueUnbind","bind_headers","matchingPairs","arguments","queueBindOk","unbind_headers","destroy","queueDeleteOk","queueClosed","queueDelete","ifUnused","ifEmpty","purge","queuePurgeOk","queuePurge","_onMethod","method","args","_handleTaskReply","apply","channelOpenOk","noDeclare","state","indexOf","queueDeclare","passive","durable","queueDeclareOk","queues","forEach","count","messageCount","consumerCount","consumerTags","Object","index","cb","basicQosOk","confirmSelectOk","_sequence","confirm","channelClose","closeOK","Error","replyText","code","replyCode","channelCloseOk","basicDeliver","currentMessage","stringify","_tasks","_tasksFlush","_onContentHeader","classInfo","weight","read","_onContent","flow","active","channelFlowOk","channelFlow"],"mappings":"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","sourcesContent":["'use strict';\nvar util = require('util');\nvar fs = require('fs');\nvar StringDecoder = require('string_decoder').StringDecoder;\nvar _ = require('lodash');\nvar Channel = require('./channel');\nvar Exchange = require('./exchange');\nvar Message = require('./message');\nvar debug = require('./debug');\nvar definitions = require('./definitions');\nvar methods = definitions.methods;\nvar classes = definitions.classes;\n\nvar Queue = module.exports = function Queue (connection, channel, name, options, callback) {\n  Channel.call(this, connection, channel);\n\n  var self = this;\n  this.name = name;\n  this._bindings = {};\n  this.consumerTagListeners = {};\n  this.consumerTagOptions = {};\n\n  // route messages to subscribers based on consumerTag\n  this.on('rawMessage', function(message) {\n    if (message.consumerTag && self.consumerTagListeners[message.consumerTag]) {\n      self.consumerTagListeners[message.consumerTag](message);\n    }\n  });\n\n  this.options = { autoDelete: true, closeChannelOnUnsubscribe: false };\n  _.assignIn(this.options, options || {});\n\n  this._openCallback = callback;\n};\nutil.inherits(Queue, Channel);\n\nQueue.prototype.subscribeRaw = function (options, messageListener, oldConsumerTag) {\n  var self = this;\n\n  // multiple method signatures\n  if (typeof options === \"function\") {\n    oldConsumerTag = messageListener;\n    messageListener = options;\n    options = {};\n  }\n\n  var consumerTag;\n  if (options.consumerTag !== undefined) {\n    consumerTag = options.consumerTag + '-' + Math.random();\n  } else {\n    consumerTag = 'node-amqp-' + process.pid + '-' + Math.random();\n  }\n  this.consumerTagListeners[consumerTag] = messageListener;\n\n  options = options || {};\n  options['state'] = 'opening';\n  this.consumerTagOptions[consumerTag] = options;\n  if (options.prefetchCount !== undefined) {\n    self.connection._sendMethod(self.channel, methods.basicQos,\n        { reserved1: 0\n        , prefetchSize: 0\n        , prefetchCount: options.prefetchCount\n        , global: false\n        });\n  }\n\n  // If this is a reconnection, we should probably tell folks their tag has changed\n  if (oldConsumerTag) {\n    debug && debug('Existing consumer tag changed', util.inspect({ oldConsumerTag: oldConsumerTag, consumerTag: consumerTag }));\n    self.connection.emit('tag.change', { oldConsumerTag: oldConsumerTag, consumerTag: consumerTag });\n  }\n\n  return this._taskPush(methods.basicConsumeOk, function () {\n    self.connection._sendMethod(self.channel, methods.basicConsume,\n        { reserved1: 0\n        , queue: self.name\n        , consumerTag: consumerTag\n        , noLocal: !!options.noLocal\n        , noAck: !!options.noAck\n        , exclusive: !!options.exclusive\n        , noWait: false\n        , \"arguments\": {}\n        });\n    self.consumerTagOptions[consumerTag]['state'] = 'open';\n  });\n};\n\nQueue.prototype.unsubscribe = function(consumerTag) {\n  var self = this;\n  return this._taskPush(methods.basicCancelOk, function () {\n    self.connection._sendMethod(self.channel, methods.basicCancel,\n                                { reserved1: 0,\n                                  consumerTag: consumerTag,\n                                  noWait: false });\n  })\n  .addCallback(function () {\n    if (self.options.closeChannelOnUnsubscribe) {\n      self.close();\n    }\n    delete self.consumerTagListeners[consumerTag];\n    delete self.consumerTagOptions[consumerTag];\n  });\n};\n\nQueue.prototype.subscribe = function (options, messageListener) {\n  var self = this;\n\n  // Optional options\n  if (typeof options === \"function\") {\n    messageListener = options;\n    options = {};\n  }\n\n  options = _.defaults(options || {}, {\n    ack: false,\n    prefetchCount: 1,\n    routingKeyInPayload: self.connection.options.routingKeyInPayload,\n    deliveryTagInPayload: self.connection.options.deliveryTagInPayload\n  });\n\n  // basic consume\n  var rawOptions = {\n      noAck: !options.ack,\n      exclusive: options.exclusive\n  };\n\n  if (options.ack) {\n    rawOptions['prefetchCount'] = options.prefetchCount;\n  }\n\n  if (options.consumerTag) {\n    rawOptions['consumerTag'] = options.consumerTag;\n  }\n\n  return this.subscribeRaw(rawOptions, function (m) {\n    var contentType = m.contentType;\n    var decoder = new StringDecoder('utf8');\n\n    if (contentType == null && m.headers && m.headers.properties) {\n      contentType = m.headers.properties.content_type;\n    }\n\n    var isJSON = contentType == 'text/json' ||\n                 contentType == 'application/json';\n\n    var buffer;\n\n    if (isJSON) {\n      buffer = \"\";\n    } else {\n      buffer = new Buffer(m.size);\n      buffer.used = 0;\n    }\n\n    self._lastMessage = m;\n\n    m.addListener('data', function (d) {\n      if (isJSON) {\n        buffer += decoder.write(d);\n      } else {\n        d.copy(buffer, buffer.used);\n        buffer.used += d.length;\n      }\n    });\n\n    m.addListener('end', function () {\n      var json, deliveryInfo = {}, msgProperties = classes[60].fields, i, l;\n\n      if (isJSON) {\n        decoder.end();\n        try {\n          json = JSON.parse(buffer);\n        } catch (e) {\n          json = null;\n          deliveryInfo.parseError = e;\n          deliveryInfo.rawData = buffer;\n        }\n      } else {\n        json = { data: buffer, contentType: m.contentType };\n      }\n\n      for (i = 0, l = msgProperties.length; i<l; i++) {\n        if (m[msgProperties[i].name]) {\n          deliveryInfo[msgProperties[i].name] = m[msgProperties[i].name];\n        }\n      }\n\n      deliveryInfo.queue = m.queue ? m.queue.name : null;\n      deliveryInfo.deliveryTag = m.deliveryTag;\n      deliveryInfo.redelivered = m.redelivered;\n      deliveryInfo.exchange = m.exchange;\n      deliveryInfo.routingKey = m.routingKey;\n      deliveryInfo.consumerTag = m.consumerTag;\n\n      if (options.routingKeyInPayload) json._routingKey = m.routingKey;\n      if (options.deliveryTagInPayload) json._deliveryTag = m.deliveryTag;\n\n      var headers = {};\n      for (i in this.headers) {\n        if (this.headers.hasOwnProperty(i)) {\n          if (this.headers[i] instanceof Buffer) {\n            headers[i] = this.headers[i].toString();\n          } else {\n            headers[i] = this.headers[i];\n          }\n        }\n      }\n\n      if (messageListener) messageListener(json, headers, deliveryInfo, m);\n      self.emit('message', json, headers, deliveryInfo, m);\n    });\n  });\n};\nQueue.prototype.subscribeJSON = Queue.prototype.subscribe;\n\n/* Acknowledges the last message */\nQueue.prototype.shift = function (reject, requeue) {\n  if (this._lastMessage) {\n    if (reject) {\n      this._lastMessage.reject(requeue ? true : false);\n    } else {\n      this._lastMessage.acknowledge();\n    }\n    this._lastMessage = null;\n  }\n};\n\n\nQueue.prototype.bind = function (exchange, routingKey, callback) {\n  var self = this;\n\n  // The first argument, exchange is optional.\n  // If not supplied the connection will use the 'amq.topic'\n  // exchange.\n  if (routingKey === undefined || _.isFunction(routingKey)) {\n    callback = routingKey;\n    routingKey = exchange;\n    exchange = 'amq.topic';\n  }\n\n  if (_.isFunction(callback)) this._bindCallback = callback;\n\n  var exchangeName = exchange instanceof Exchange ? exchange.name : exchange;\n\n  if (exchangeName in self.connection.exchanges) {\n    this.exchange = self.connection.exchanges[exchangeName];\n    this.exchange.binds++;\n  }\n\n  // Record this binding so we can restore it upon reconnect.\n  if (!this._bindings[exchangeName]) {\n    this._bindings[exchangeName] = {};\n  }\n\n  if (!this._bindings[exchangeName][routingKey]) {\n    this._bindings[exchangeName][routingKey] = 0;\n  }\n\n  this._bindings[exchangeName][routingKey]++;\n\n  self.connection._sendMethod(self.channel, methods.queueBind,\n      { reserved1: 0\n      , queue: self.name\n      , exchange: exchangeName\n      , routingKey: routingKey\n      , noWait: false\n      , \"arguments\": {}\n      });\n\n};\n\nQueue.prototype.unbind = function (exchange, routingKey) {\n  var self = this;\n\n  // The first argument, exchange is optional.\n  // If not supplied the connection will use the default 'amq.topic'\n  // exchange.\n  if (routingKey === undefined) {\n    routingKey = exchange;\n    exchange = 'amq.topic';\n  }\n\n  var exchangeName = exchange instanceof Exchange ? exchange.name : exchange;\n\n  if(this._bindings[exchangeName]) {\n    // Decrement binding count.\n    this._bindings[exchangeName][routingKey]--;\n    if (!this._bindings[exchangeName][routingKey]) {\n      delete this._bindings[exchangeName][routingKey];\n    }\n\n    // If there are no more bindings to this exchange, delete the key for the exchange.\n    if (!_.keys(this._bindings[exchangeName]).length){\n      delete this._bindings[exchangeName];\n    }\n  }\n\n  return this._taskPush(methods.queueUnbindOk, function () {\n    self.connection._sendMethod(self.channel, methods.queueUnbind,\n        { reserved1: 0\n        , queue: self.name\n        , exchange: exchangeName\n        , routingKey: routingKey\n        , noWait: false\n        , \"arguments\": {}\n        });\n  });\n};\n\nQueue.prototype.bind_headers = function (/* [exchange,] matchingPairs */) {\n  var self = this;\n\n  // The first argument, exchange is optional.\n  // If not supplied the connection will use the default 'amq.headers'\n  // exchange.\n\n  var exchange, matchingPairs;\n\n  if (arguments.length == 2) {\n    exchange = arguments[0];\n    matchingPairs = arguments[1];\n  } else {\n    exchange = 'amq.headers';\n    matchingPairs = arguments[0];\n  }\n\n\n  return this._taskPush(methods.queueBindOk, function () {\n    var exchangeName = exchange instanceof Exchange ? exchange.name : exchange;\n    self.connection._sendMethod(self.channel, methods.queueBind,\n        { reserved1: 0\n        , queue: self.name\n        , exchange: exchangeName\n        , routingKey: ''\n        , noWait: false\n        , \"arguments\": matchingPairs\n        });\n  });\n};\n\nQueue.prototype.unbind_headers = function (/* [exchange,] matchingPairs */) {\n  var self = this;\n\n  // The first argument, exchange is optional.\n  // If not supplied the connection will use the default 'amq.topic'\n  // exchange.\n\n  var exchange, matchingPairs;\n\n  if (arguments.length === 2) {\n    exchange = arguments[0];\n    matchingPairs = arguments[1];\n  } else {\n    exchange = 'amq.headers';\n    matchingPairs = arguments[0];\n  }\n\n  return this._taskPush(methods.queueUnbindOk, function () {\n    var exchangeName = exchange instanceof Exchange ? exchange.name : exchange;\n    self.connection._sendMethod(self.channel, methods.queueUnbind,\n        { reserved1: 0\n        , queue: self.name\n        , exchange: exchangeName\n        , routingKey: ''\n        , noWait: false\n        , \"arguments\": matchingPairs\n        });\n  });\n};\n\nQueue.prototype.destroy = function (options) {\n  var self = this;\n\n  options = options || {};\n  return this._taskPush(methods.queueDeleteOk, function () {\n    self.connection.queueClosed(self.name);\n    if ('exchange' in self) {\n      self.exchange.binds--;\n    }\n    self.connection._sendMethod(self.channel, methods.queueDelete,\n        { reserved1: 0\n        , queue: self.name\n        , ifUnused: options.ifUnused ? true : false\n        , ifEmpty: options.ifEmpty ? true : false\n        , noWait: false\n        , \"arguments\": {}\n    });\n  });\n};\n\nQueue.prototype.purge = function() {\n  var self = this;\n  return this._taskPush(methods.queuePurgeOk, function () {\n    self.connection._sendMethod(self.channel, methods.queuePurge,\n                                 { reserved1 : 0,\n                                 queue: self.name,\n                                 noWait: false});\n  });\n};\n\n\nQueue.prototype._onMethod = function (channel, method, args) {\n  var self = this;\n  this.emit(method.name, args);\n  if (this._handleTaskReply.apply(this, arguments)) return;\n\n  switch (method) {\n    case methods.channelOpenOk:\n      if (this.options.noDeclare) {\n        this.state = 'open';\n\n        if (this._openCallback) {\n         this._openCallback(this);\n         this._openCallback = null;\n        }\n\n        this.emit('open');\n      } else {\n        if (this.name.indexOf('amq.') == 0) {\n          this.name = '';\n        }\n        this.connection._sendMethod(channel, methods.queueDeclare,\n            { reserved1: 0\n            , queue: this.name\n            , passive: !!this.options.passive\n            , durable: !!this.options.durable\n            , exclusive: !!this.options.exclusive\n            , autoDelete: !!this.options.autoDelete\n            , noWait: false\n            , \"arguments\": this.options.arguments || {}\n            });\n        this.state = \"declare queue\";\n      }\n      break;\n\n    case methods.queueDeclareOk:\n      this.state = 'open';\n      this.name = args.queue;\n      this.connection.queues[this.name] = this;\n\n      // Rebind to previously bound exchanges, if present.\n      // Important this is called *before* openCallback, otherwise bindings will happen twice.\n      // Run test-purge to make sure you got this right\n      _.forEach(this._bindings, function(exchange, exchangeName){\n        _.forEach(exchange, function(count, routingKey){\n          self.bind(exchangeName, routingKey);\n        });\n      });\n\n      // Call opening callback (passed in function)\n      // FIXME use eventemitter - maybe we call a namespaced event here\n      if (this._openCallback) {\n        this._openCallback(this, args.messageCount, args.consumerCount);\n        this._openCallback = null;\n      }\n\n      // TODO this is legacy interface, remove me\n      this.emit('open', args.queue, args.messageCount, args.consumerCount);\n\n      // If this is a reconnect, we must re-subscribe our queue listeners.\n      var consumerTags = Object.keys(this.consumerTagListeners);\n      for (var index in consumerTags) {\n        if (consumerTags.hasOwnProperty(index)) {\n          if (this.consumerTagOptions[consumerTags[index]]['state'] === 'closed') {\n            this.subscribeRaw(this.consumerTagOptions[consumerTags[index]], this.consumerTagListeners[consumerTags[index]], consumerTags[index]);\n            // Having called subscribeRaw, we are now a new consumer with a new consumerTag.\n            delete this.consumerTagListeners[consumerTags[index]];\n            delete this.consumerTagOptions[consumerTags[index]];\n          }\n        }\n      }\n      break;\n\n    case methods.basicConsumeOk:\n      debug && debug('basicConsumeOk', util.inspect(args, null));\n      break;\n\n    case methods.queueBindOk:\n      if (this._bindCallback) {\n        // setting this._bindCallback to null before calling the callback allows for a subsequent bind within the callback\n        // FIXME use eventemitter\n        var cb = this._bindCallback;\n        this._bindCallback = null;\n        cb(this);\n      }\n      break;\n\n    case methods.queueUnbindOk:\n      break;\n\n    case methods.basicQosOk:\n      break;\n\n    case methods.confirmSelectOk:\n      this._sequence = 1;\n      this.confirm = true;\n      break;\n\n    case methods.channelClose:\n      this.state = \"closed\";\n      this.closeOK();\n      this.connection.queueClosed(this.name);\n      var e = new Error(args.replyText);\n      e.code = args.replyCode;\n      this.emit('error', e);\n      this.emit('close');\n      break;\n\n    case methods.channelCloseOk:\n      this.connection.queueClosed(this.name);\n      this.emit('close');\n      break;\n\n    case methods.basicDeliver:\n      this.currentMessage = new Message(this, args);\n      break;\n\n    case methods.queueDeleteOk:\n      break;\n\n    case methods.basicCancel:\n      this.close(\"Closed due to basicCancel received on consumer (\" + args.consumerTag + \")\");\n      break;\n\n    default:\n      throw new Error(\"Uncaught method '\" + method.name + \"' with args \" +\n          JSON.stringify(args) + \"; tasks = \" + JSON.stringify(this._tasks));\n  }\n\n  this._tasksFlush();\n};\n\n\nQueue.prototype._onContentHeader = function (channel, classInfo, weight, properties, size) {\n  _.assignIn(this.currentMessage, properties);\n  this.currentMessage.read = 0;\n  this.currentMessage.size = size;\n\n  this.emit('rawMessage', this.currentMessage);\n  if (size === 0) {\n    // If the message has no body, directly emit 'end'\n    this.currentMessage.emit('end');\n  }\n};\n\nQueue.prototype._onContent = function (channel, data) {\n  this.currentMessage.read += data.length;\n  this.currentMessage.emit('data', data);\n  if (this.currentMessage.read == this.currentMessage.size) {\n    this.currentMessage.emit('end');\n  }\n};\n\nQueue.prototype.flow = function(active) {\n  var self = this;\n  return this._taskPush(methods.channelFlowOk, function () {\n    self.connection._sendMethod(self.channel, methods.channelFlow, {'active': active });\n  });\n};\n"]},"metadata":{},"sourceType":"script"}