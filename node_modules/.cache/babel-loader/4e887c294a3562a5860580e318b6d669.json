{"ast":null,"code":"'use strict';\n\nvar net = require('net');\n\nvar tls = require('tls');\n\nvar fs = require('fs');\n\nvar URL = require('url');\n\nvar _ = require('lodash');\n\nvar debug = require('./debug');\n\nvar EventEmitter = require('events').EventEmitter;\n\nvar util = require('util');\n\nvar serializer = require('./serializer');\n\nvar definitions = require('./definitions');\n\nvar methods = definitions.methods;\nvar methodTable = definitions.methodTable;\nvar classes = definitions.classes;\n\nvar Exchange = require('./exchange');\n\nvar Queue = require('./queue');\n\nvar AMQPParser = require('./parser');\n\nvar nodeAMQPVersion = require('../package').version;\n\nvar maxFrameBuffer = 131072; // 128k, same as rabbitmq (which was\n// copying qpid)\n\nvar channelMax = 65535;\nvar defaultPorts = {\n  'amqp': 5672,\n  'amqps': 5671\n};\nvar defaultOptions = {\n  host: 'localhost',\n  port: defaultPorts['amqp'],\n  login: 'guest',\n  password: 'guest',\n  authMechanism: 'AMQPLAIN',\n  vhost: '/',\n  connectionTimeout: 10000,\n  ssl: {\n    enabled: false\n  }\n};\nvar defaultSslOptions = {\n  port: defaultPorts['amqps'],\n  ssl: {\n    rejectUnauthorized: true\n  }\n};\nvar defaultImplOptions = {\n  defaultExchangeName: '',\n  reconnect: true,\n  reconnectBackoffStrategy: 'linear',\n  reconnectExponentialLimit: 120000,\n  reconnectBackoffTime: 1000\n};\nvar defaultClientProperties = {\n  version: nodeAMQPVersion,\n  platform: 'node-' + process.version,\n  product: 'node-amqp'\n};\n\nvar Connection = module.exports = function Connection(connectionArgs, options, readyCallback) {\n  EventEmitter.call(this);\n  this.setOptions(connectionArgs);\n  this.setImplOptions(options);\n\n  if (typeof readyCallback === 'function') {\n    this._readyCallback = readyCallback;\n  }\n\n  this.connectionAttemptScheduled = false;\n  this._defaultExchange = null;\n  this.channelCounter = 0;\n  this._sendBuffer = new Buffer(maxFrameBuffer);\n  this._blocked = false;\n  this._blockedReason = null;\n};\n\nutil.inherits(Connection, EventEmitter);\n\nConnection.prototype.setOptions = function (options) {\n  var urlo = options && options.url ? this._parseURLOptions(options.url) : {};\n  var sslo = options && options.ssl && options.ssl.enabled ? defaultSslOptions : {};\n  this.options = _.assignIn({}, defaultOptions, sslo, urlo, options || {});\n  this.options.clientProperties = _.assignIn({}, defaultClientProperties, options && options.clientProperties || {});\n};\n\nConnection.prototype.setImplOptions = function (options) {\n  this.implOptions = _.assignIn({}, defaultImplOptions, options || {});\n};\n\nConnection.prototype.connect = function () {\n  // If this is our first connection, add listeners.\n  if (!this.socket) this.addAllListeners();\n\n  this._createSocket();\n\n  this._startHandshake();\n};\n\nConnection.prototype.reconnect = function () {\n  // Suspend activity on channels\n  for (var channel in this.channels) {\n    this.channels[channel].state = 'closed';\n  }\n\n  debug && debug(\"Connection lost, reconnecting...\"); // Terminate socket activity\n\n  if (this.socket) this.socket.end();\n  this.connect();\n};\n\nConnection.prototype.disconnect = function () {\n  debug && debug(\"Sending disconnect request to server\");\n\n  this._sendMethod(0, methods.connectionClose, {\n    'replyText': 'client disconnect',\n    'replyCode': 200,\n    'classId': 0,\n    'methodId': 0\n  });\n};\n\nConnection.prototype.addAllListeners = function () {\n  var self = this;\n  var connectEvent = this.options.ssl.enabled ? 'secureConnect' : 'connect';\n  self.addListener(connectEvent, function () {\n    // In the case where this is a reconnection, do not trample on the existing\n    // channels.\n    // For your reference, channel 0 is the control channel.\n    self.channels = self.channels || {\n      0: self\n    };\n    self.queues = self.queues || {};\n    self.exchanges = self.exchanges || {};\n    self.parser = new AMQPParser('0-9-1', 'client');\n\n    self.parser.onMethod = function (channel, method, args) {\n      self._onMethod(channel, method, args);\n    };\n\n    self.parser.onContent = function (channel, data) {\n      debug && debug(channel + \" > content \" + data.length);\n\n      if (self.channels[channel] && self.channels[channel]._onContent) {\n        self.channels[channel]._onContent(channel, data);\n      } else {\n        debug && debug(\"unhandled content: \" + data);\n      }\n    };\n\n    self.parser.onContentHeader = function (channel, classInfo, weight, properties, size) {\n      debug && debug(channel + \" > content header \" + JSON.stringify([classInfo.name, weight, properties, size]));\n\n      if (self.channels[channel] && self.channels[channel]._onContentHeader) {\n        self.channels[channel]._onContentHeader(channel, classInfo, weight, properties, size);\n      } else {\n        debug && debug(\"unhandled content header\");\n      }\n    };\n\n    self.parser.onHeartBeat = function () {\n      self.emit(\"heartbeat\");\n      debug && debug(\"heartbeat\");\n    };\n\n    self.parser.onError = function (e) {\n      self.emit(\"error\", e);\n      self.emit(\"close\");\n    }; // Remove readyEmitted flag so we can detect an auth error.\n\n\n    self.readyEmitted = false;\n  });\n  self.addListener('data', function (data) {\n    if (self.parser != null) {\n      try {\n        self.parser.execute(data);\n      } catch (exception) {\n        self.emit('error', exception);\n        return;\n      }\n    }\n\n    self._inboundHeartbeatTimerReset();\n  });\n  var backoffTime = null;\n  self.addListener('error', function backoff(e) {\n    if (self._inboundHeartbeatTimer !== null) {\n      clearTimeout(self._inboundHeartbeatTimer);\n      self._inboundHeartbeatTimer = null;\n    }\n\n    if (self._outboundHeartbeatTimer !== null) {\n      clearTimeout(self._outboundHeartbeatTimer);\n      self._outboundHeartbeatTimer = null;\n    }\n\n    if (!self.connectionAttemptScheduled) {\n      // Set to true, as we are presently in the process of scheduling one.\n      self.connectionAttemptScheduled = true; // Kill the socket, if it hasn't been killed already.\n\n      self.socket.end(); // Reset parser state\n\n      self.parser = null; // In order for our reconnection to be seamless, we have to notify the\n      // channels that they are no longer connected so that nobody attempts\n      // to send messages which would be doomed to fail.\n\n      for (var channel in self.channels) {\n        if (channel !== '0') {\n          self.channels[channel].state = 'closed';\n        }\n      } // Queues are channels (so we have already marked them as closed), but\n      // queues have special needs, since the subscriptions will no longer\n      // be known to the server when we reconnect.  Mark the subscriptions as\n      // closed so that we can resubscribe them once we are reconnected.\n\n\n      for (var queue in self.queues) {\n        for (var index in self.queues[queue].consumerTagOptions) {\n          self.queues[queue].consumerTagOptions[index]['state'] = 'closed';\n        }\n      } // Begin reconnection attempts\n\n\n      if (self.implOptions.reconnect) {\n        // Don't thrash, use a backoff strategy.\n        if (backoffTime === null) {\n          // This is the first time we've failed since a successful connection,\n          // so use the configured backoff time without any modification.\n          backoffTime = self.implOptions.reconnectBackoffTime;\n        } else if (self.implOptions.reconnectBackoffStrategy === 'exponential') {\n          // If you've configured exponential backoff, we'll double the\n          // backoff time each subsequent attempt until success.\n          backoffTime *= 2; // limit the maxium timeout, to avoid potentially unlimited stalls\n\n          if (backoffTime > self.implOptions.reconnectExponentialLimit) {\n            backoffTime = self.implOptions.reconnectExponentialLimit;\n          }\n        } else if (self.implOptions.reconnectBackoffStrategy === 'linear') {// Linear strategy is the default.  In this case, we will retry at a\n          // constant interval, so there's no need to change the backoff time\n          // between attempts.\n        } else {// TODO should we warn people if they picked a nonexistent strategy?\n          }\n\n        setTimeout(function () {\n          // Set to false, so that if we fail in the reconnect attempt, we can\n          // schedule another one.\n          self.connectionAttemptScheduled = false;\n          self.reconnect();\n        }, backoffTime);\n      } else {\n        self.removeListener('error', backoff);\n      }\n    }\n  });\n  self.addListener('ready', function () {\n    // Reset the backoff time since we have successfully connected.\n    backoffTime = null;\n\n    if (self.implOptions.reconnect) {\n      // Reconnect any channels which were open.\n      _.forEach(self.channels, function (channel, index) {\n        if (index !== '0') channel.reconnect();\n      });\n    } // Set 'ready' flag for auth failure detection.\n\n\n    this.readyEmitted = true; // Restart the heartbeat to the server\n\n    self._outboundHeartbeatTimerReset();\n  }); // Apparently, it is not possible to determine if an authentication error\n  // has occurred, but when the connection closes then we can HINT that a\n  // possible authentication error has occured.  Although this may be a bug\n  // in the spec, handling it as a possible error is considerably better than\n  // failing silently.\n\n  self.addListener('end', function () {\n    if (!this.readyEmitted) {\n      this.emit('error', new Error('Connection ended: possibly due to an authentication failure.'));\n    }\n  });\n};\n\nConnection.prototype.heartbeat = function () {\n  if (this.socket.writable) this.write(new Buffer([8, 0, 0, 0, 0, 0, 0, 206]));\n}; // connection.exchange('my-exchange', { type: 'topic' });\n// Options\n// - type 'fanout', 'direct', or 'topic' (default)\n// - passive (boolean)\n// - durable (boolean)\n// - autoDelete (boolean, default true)\n\n\nConnection.prototype.exchange = function (name, options, openCallback) {\n  if (name === undefined) name = this.implOptions.defaultExchangeName;\n  if (!options) options = {};\n  if (name !== '' && options.type === undefined) options.type = 'topic';\n\n  try {\n    var channel = this.generateChannelId();\n  } catch (exception) {\n    this.emit(\"error\", exception);\n    return;\n  }\n\n  var exchange = new Exchange(this, channel, name, options, openCallback);\n  this.channels[channel] = exchange;\n  this.exchanges[name] = exchange;\n  return exchange;\n}; // remove an exchange when it's closed (called from Exchange)\n\n\nConnection.prototype.exchangeClosed = function (name) {\n  if (this.exchanges[name]) delete this.exchanges[name];\n}; // Options\n// - passive (boolean)\n// - durable (boolean)\n// - exclusive (boolean)\n// - autoDelete (boolean, default true)\n\n\nConnection.prototype.queue = function (name\n/* options, openCallback */\n) {\n  var options, callback;\n\n  if (typeof arguments[1] == 'object') {\n    options = arguments[1];\n    callback = arguments[2];\n  } else {\n    callback = arguments[1];\n  }\n\n  try {\n    var channel = this.generateChannelId();\n  } catch (exception) {\n    this.emit(\"error\", exception);\n    return;\n  }\n\n  var q = new Queue(this, channel, name, options, callback);\n  this.channels[channel] = q;\n  return q;\n}; // remove a queue when it's closed (called from Queue)\n\n\nConnection.prototype.queueClosed = function (name) {\n  if (this.queues[name]) delete this.queues[name];\n}; // Publishes a message to the default exchange.\n\n\nConnection.prototype.publish = function (routingKey, body, options, callback) {\n  if (!this._defaultExchange) {\n    this._defaultExchange = this.exchange();\n  }\n\n  var exchange = this._defaultExchange;\n\n  if (exchange.state === 'open') {\n    exchange.publish(routingKey, body, options, callback);\n  } else {\n    exchange.once('open', function () {\n      exchange.publish(routingKey, body, options, callback);\n    });\n  }\n};\n\nConnection.prototype._bodyToBuffer = function (body) {\n  // Handles 3 cases\n  // - body is utf8 string\n  // - body is instance of Buffer\n  // - body is an object and its JSON representation is sent\n  // Does not handle the case for streaming bodies.\n  // Returns buffer.\n  if (typeof body == 'string') {\n    return [null, new Buffer(body, 'utf8')];\n  } else if (body instanceof Buffer) {\n    return [null, body];\n  } else {\n    var jsonBody = JSON.stringify(body);\n    debug && debug('sending json: ' + jsonBody);\n    var props = {\n      contentType: 'application/json'\n    };\n    return [props, new Buffer(jsonBody, 'utf8')];\n  }\n};\n\nConnection.prototype._inboundHeartbeatTimerReset = function () {\n  if (this._inboundHeartbeatTimer !== null) {\n    clearTimeout(this._inboundHeartbeatTimer);\n    this._inboundHeartbeatTimer = null;\n  }\n\n  if (this.options.heartbeat) {\n    var self = this;\n    var gracePeriod = 2 * this.options.heartbeat;\n    this._inboundHeartbeatTimer = setTimeout(function () {\n      if (self.socket.readable || self.options.heartbeatForceReconnect) {\n        self.emit('error', new Error('no heartbeat or data in last ' + gracePeriod + ' seconds'));\n      }\n    }, gracePeriod * 1000);\n  }\n};\n\nConnection.prototype._outboundHeartbeatTimerReset = function () {\n  if (this._outboundHeartbeatTimer !== null) {\n    clearTimeout(this._outboundHeartbeatTimer);\n    this._outboundHeartbeatTimer = null;\n  }\n\n  if (this.socket.writable && this.options.heartbeat) {\n    var self = this;\n    this._outboundHeartbeatTimer = setTimeout(function () {\n      self.heartbeat();\n\n      self._outboundHeartbeatTimerReset();\n    }, 1000 * this.options.heartbeat);\n  }\n};\n\nConnection.prototype._saslResponse = function () {\n  var response;\n  if (this.options.authMechanism == 'AMQPLAIN') response = {\n    LOGIN: this.options.login,\n    PASSWORD: this.options.password\n  };else if (this.options.authMechanism == 'PLAIN') response = \"\\0\" + this.options.login + \"\\0\" + this.options.password;else if (this.options.authMechanism == 'EXTERNAL') response = \"\\0\";else if (this.options.authMechanism == 'ANONYMOUS') response = \"\\0\";else response = this.options.response;\n  return response;\n};\n\nConnection.prototype._onMethod = function (channel, method, args) {\n  debug && debug(channel + \" > \" + method.name + \" \" + JSON.stringify(args)); // Channel 0 is the control channel. If not zero then delegate to\n  // one of the channel objects.\n\n  if (channel > 0) {\n    if (!this.channels[channel]) {\n      debug && debug(\"Received message on untracked channel.\");\n      return;\n    }\n\n    if (!this.channels[channel]._onChannelMethod) {\n      throw new Error('Channel ' + channel + ' has no _onChannelMethod method.');\n    }\n\n    this.channels[channel]._onChannelMethod(channel, method, args);\n\n    return;\n  } // channel 0\n\n\n  switch (method) {\n    // 2. The server responds, after the version string, with the\n    // 'connectionStart' method (contains various useless information)\n    case methods.connectionStart:\n      // We check that they're serving us AMQP 0-9\n      if (args.versionMajor !== 0 && args.versionMinor != 9) {\n        this.socket.end();\n        this.emit('error', new Error(\"Bad server version\"));\n        return;\n      }\n\n      this.serverProperties = args.serverProperties; // 3. Then we reply with StartOk, containing our useless information.\n\n      this._sendMethod(0, methods.connectionStartOk, {\n        clientProperties: this.options.clientProperties,\n        mechanism: this.options.authMechanism,\n        response: this._saslResponse(),\n        locale: 'en_US'\n      });\n\n      break;\n    // 4. The server responds with a connectionTune request\n\n    case methods.connectionTune:\n      if (args.frameMax) {\n        debug && debug(\"tweaking maxFrameBuffer to \" + args.frameMax);\n        maxFrameBuffer = args.frameMax;\n        this._sendBuffer = new Buffer(maxFrameBuffer);\n        this.parser.setMaxFrameBuffer(maxFrameBuffer);\n      }\n\n      if (args.channelMax) {\n        debug && debug(\"tweaking channelMax to \" + args.channelMax);\n        channelMax = args.channelMax;\n      } // 5. We respond with connectionTuneOk\n\n\n      this._sendMethod(0, methods.connectionTuneOk, {\n        channelMax: channelMax,\n        frameMax: maxFrameBuffer,\n        heartbeat: this.options.heartbeat || 0\n      }); // 6. Then we have to send a connectionOpen request\n\n\n      this._sendMethod(0, methods.connectionOpen, {\n        virtualHost: this.options.vhost // , capabilities: ''\n        // , insist: true\n        ,\n        reserved1: '',\n        reserved2: true\n      });\n\n      break;\n\n    case methods.connectionOpenOk:\n      // 7. Finally they respond with connectionOpenOk\n      // Whew! That's why they call it the Advanced MQP.\n      if (this._readyCallback) {\n        this._readyCallback(this);\n\n        this._readyCallback = null;\n      }\n\n      this.emit('ready');\n      break;\n\n    case methods.connectionClose:\n      var e = new Error(args.replyText);\n      e.code = args.replyCode;\n\n      if (!this.listeners('close').length) {\n        console.log('Unhandled connection error: ' + args.replyText);\n      }\n\n      this.socket.destroy(e);\n      break;\n\n    case methods.connectionCloseOk:\n      debug && debug(\"Received close-ok from server, closing socket\");\n      this.socket.end();\n      this.socket.destroy();\n      break;\n\n    case methods.connectionBlocked:\n      debug && debug('Received connection.blocked from server with reason: ' + args.reason);\n      this._blocked = true;\n      this._blockedReason = args.reason;\n      this.emit('blocked');\n      break;\n\n    case methods.connectionUnblocked:\n      debug && debug('Received connection.unblocked from server');\n      this._blocked = false;\n      this._blockedReason = null;\n      this.emit('unblocked');\n      break;\n\n    default:\n      throw new Error(\"Uncaught method '\" + method.name + \"' with args \" + JSON.stringify(args));\n  }\n}; // Generate connection options from URI string formatted with amqp scheme.\n\n\nConnection.prototype._parseURLOptions = function (connectionString) {\n  var opts = {};\n  opts.ssl = {};\n  var url = URL.parse(connectionString);\n  var scheme = url.protocol.substring(0, url.protocol.lastIndexOf(':'));\n\n  if (scheme != 'amqp' && scheme != 'amqps') {\n    throw new Error('Connection URI must use amqp or amqps scheme. ' + 'For example, \"amqp://bus.megacorp.internal:5766\".');\n  }\n\n  opts.ssl.enabled = 'amqps' === scheme;\n  opts.host = url.hostname;\n  opts.port = url.port || defaultPorts[scheme];\n\n  if (url.auth) {\n    var auth = url.auth.split(':');\n    auth[0] && (opts.login = auth[0]);\n    auth[1] && (opts.password = auth[1]);\n  }\n\n  if (url.pathname) {\n    opts.vhost = unescape(url.pathname.substr(1));\n  }\n\n  return opts;\n};\n/*\n *\n * Connect helpers\n *\n */\n// If you pass a array of hosts, lets choose a random host or the preferred host number, or then next one.\n\n\nConnection.prototype._chooseHost = function () {\n  if (Array.isArray(this.options.host)) {\n    if (this.hosti == null) {\n      if (typeof this.options.hostPreference == 'number') {\n        this.hosti = this.options.hostPreference < this.options.host.length ? this.options.hostPreference : this.options.host.length - 1;\n      } else {\n        this.hosti = parseInt(Math.random() * this.options.host.length, 10);\n      }\n    } else {\n      // If this is already set, it looks like we want to choose another one.\n      // Add one to hosti but don't overflow it.\n      this.hosti = (this.hosti + 1) % this.options.host.length;\n    }\n\n    return this.options.host[this.hosti];\n  } else {\n    return this.options.host;\n  }\n};\n\nConnection.prototype._createSocket = function () {\n  var hostName = this._chooseHost(),\n      self = this,\n      port = this.options.port;\n\n  var parsedHost = URL.parse(hostName);\n\n  if (parsedHost.port) {\n    hostName = parsedHost.hostname;\n    port = parsedHost.port;\n  }\n\n  var options = {\n    port: port,\n    host: hostName\n  }; // Disable tcp nagle's algo\n  // Default: true, makes small messages faster\n\n  var noDelay = this.options.noDelay || true;\n\n  var resetConnectionTimeout = function () {\n    debug && debug('connected so resetting connection timeout');\n    this.setTimeout(0);\n  }; // Connect socket\n\n\n  if (this.options.ssl.enabled) {\n    debug && debug('making ssl connection');\n    options = _.assignIn(options, this._getSSLOptions());\n    this.socket = tls.connect(options, resetConnectionTimeout);\n  } else {\n    debug && debug('making non-ssl connection');\n    this.socket = net.connect(options, resetConnectionTimeout);\n  }\n\n  var connTimeout = this.options.connectionTimeout;\n\n  if (connTimeout) {\n    debug && debug('setting connection timeout to ' + connTimeout);\n    this.socket.setTimeout(connTimeout, function () {\n      debug && debug('connection timeout');\n      this.destroy();\n      var e = new Error('connection timeout');\n      e.name = 'TimeoutError';\n      self.emit('error', e);\n    });\n  }\n\n  this.socket.setNoDelay(noDelay); // Proxy events.\n  // Note that if we don't attach a 'data' event, no data will flow.\n\n  var events = ['close', 'connect', 'data', 'drain', 'error', 'end', 'secureConnect', 'timeout'];\n\n  _.forEach(events, function (event) {\n    self.socket.on(event, self.emit.bind(self, event));\n  }); // Proxy a few methods that we use / previously used.\n\n\n  var methods = ['destroy', 'write', 'pause', 'resume', 'setEncoding', 'ref', 'unref', 'address'];\n\n  _.forEach(methods, function (method) {\n    self[method] = function () {\n      self.socket[method].apply(self.socket, arguments);\n    };\n  });\n};\n\nConnection.prototype.end = function () {\n  if (this.socket) {\n    this.socket.end();\n  }\n\n  this.options.heartbeat = false;\n\n  if (this._inboundHeartbeatTimer !== null) {\n    clearTimeout(this._inboundHeartbeatTimer);\n    this._inboundHeartbeatTimer = null;\n  }\n\n  if (this._outboundHeartbeatTimer !== null) {\n    clearTimeout(this._outboundHeartbeatTimer);\n    this._outboundHeartbeatTimer = null;\n  }\n};\n\nConnection.prototype._getSSLOptions = function () {\n  if (this.sslConnectionOptions) return this.sslConnectionOptions;\n  this.sslConnectionOptions = {};\n\n  if (this.options.ssl.pfxFile) {\n    this.sslConnectionOptions.pfx = fs.readFileSync(this.options.ssl.pfxFile);\n  }\n\n  if (this.options.ssl.keyFile) {\n    this.sslConnectionOptions.key = fs.readFileSync(this.options.ssl.keyFile);\n  }\n\n  if (this.options.ssl.certFile) {\n    this.sslConnectionOptions.cert = fs.readFileSync(this.options.ssl.certFile);\n  }\n\n  if (this.options.ssl.caFile) {\n    if (Array.isArray(this.options.ssl.caFile)) {\n      this.sslConnectionOptions.ca = this.options.ssl.caFile.map(function (f) {\n        return fs.readFileSync(f);\n      });\n    } else {\n      this.sslConnectionOptions.ca = fs.readFileSync(this.options.ssl.caFile);\n    }\n  }\n\n  this.sslConnectionOptions.rejectUnauthorized = this.options.ssl.rejectUnauthorized;\n  this.sslConnectionOptions.passphrase = this.options.ssl.passphrase;\n\n  if (this.options.ssl.ciphers) {\n    this.sslConnectionOptions.ciphers = this.options.ssl.ciphers;\n  }\n\n  if (this.options.ssl.secureProtocol) {\n    this.sslConnectionOptions.secureProtocol = this.options.ssl.secureProtocol;\n  }\n\n  return this.sslConnectionOptions;\n}; // Time to start the AMQP 7-way connection initialization handshake!\n// 1. The client sends the server a version string\n\n\nConnection.prototype._startHandshake = function () {\n  debug && debug(\"Initiating handshake...\");\n  this.write(\"AMQP\" + String.fromCharCode(0, 0, 9, 1));\n};\n/*\n *\n * Parse helpers\n *\n */\n\n\nConnection.prototype._sendBody = function (channel, body, properties) {\n  var r = this._bodyToBuffer(body);\n\n  var props = r[0],\n      buffer = r[1];\n  properties = _.assignIn(props || {}, properties);\n\n  this._sendHeader(channel, buffer.length, properties);\n\n  var pos = 0,\n      len = buffer.length;\n  var metaSize = 8; // headerBytes = 7, frameEndBytes = 1\n\n  var maxBodySize = maxFrameBuffer - metaSize;\n\n  while (len > 0) {\n    var bodySize = len < maxBodySize ? len : maxBodySize;\n    var frameSize = bodySize + metaSize;\n    var b = new Buffer(frameSize);\n    b.used = 0;\n    b[b.used++] = 3; // constants.frameBody\n\n    serializer.serializeInt(b, 2, channel);\n    serializer.serializeInt(b, 4, bodySize);\n    buffer.copy(b, b.used, pos, pos + bodySize);\n    b.used += bodySize;\n    b[b.used++] = 206; // constants.frameEnd;\n\n    this.write(b);\n    len -= bodySize;\n    pos += bodySize;\n  }\n\n  return;\n}; // connection: the connection\n// channel: the channel to send this on\n// size: size in bytes of the following message\n// properties: an object containing any of the following:\n// - contentType (default 'application/octet-stream')\n// - contentEncoding\n// - headers\n// - deliveryMode\n// - priority (0-9)\n// - correlationId\n// - replyTo\n// - expiration\n// - messageId\n// - timestamp\n// - userId\n// - appId\n// - clusterId\n\n\nConnection.prototype._sendHeader = function (channel, size, properties) {\n  var b = new Buffer(maxFrameBuffer); // FIXME allocating too much.\n  // use freelist?\n\n  b.used = 0;\n  var classInfo = classes[60]; // always basic class.\n  // 7 OCTET FRAME HEADER\n\n  b[b.used++] = 2; // constants.frameHeader\n\n  serializer.serializeInt(b, 2, channel);\n  var lengthStart = b.used;\n  serializer.serializeInt(b, 4, 0\n  /*dummy*/\n  ); // length\n\n  var bodyStart = b.used; // HEADER'S BODY\n\n  serializer.serializeInt(b, 2, classInfo.index); // class 60 for Basic\n\n  serializer.serializeInt(b, 2, 0); // weight, always 0 for rabbitmq\n\n  serializer.serializeInt(b, 8, size); // byte size of body\n  // properties - first propertyFlags\n\n  properties = _.defaults(properties || {}, {\n    contentType: 'application/octet-stream'\n  });\n  var propertyFlags = 0;\n\n  for (var i = 0; i < classInfo.fields.length; i++) {\n    if (properties[classInfo.fields[i].name]) propertyFlags |= 1 << 15 - i;\n  }\n\n  serializer.serializeInt(b, 2, propertyFlags); // now the actual properties.\n\n  serializer.serializeFields(b, classInfo.fields, properties, false); //serializeTable(b, properties);\n\n  var bodyEnd = b.used; // Go back to the header and write in the length now that we know it.\n\n  b.used = lengthStart;\n  serializer.serializeInt(b, 4, bodyEnd - bodyStart);\n  b.used = bodyEnd; // 1 OCTET END\n\n  b[b.used++] = 206; // constants.frameEnd;\n\n  var s = new Buffer(b.used);\n  b.copy(s); //debug && debug('header sent: ' + JSON.stringify(s));\n\n  this.write(s);\n};\n\nConnection.prototype._sendMethod = function (channel, method, args) {\n  debug && debug(channel + \" < \" + method.name + \" \" + JSON.stringify(args));\n  var b = this._sendBuffer;\n  b.used = 0;\n  b[b.used++] = 1; // constants.frameMethod\n\n  serializer.serializeInt(b, 2, channel);\n  var lengthIndex = b.used;\n  serializer.serializeInt(b, 4, 42); // replace with actual length.\n\n  var startIndex = b.used;\n  serializer.serializeInt(b, 2, method.classIndex); // short, classId\n\n  serializer.serializeInt(b, 2, method.methodIndex); // short, methodId\n\n  serializer.serializeFields(b, method.fields, args, true);\n  var endIndex = b.used; // write in the frame length now that we know it.\n\n  b.used = lengthIndex;\n  serializer.serializeInt(b, 4, endIndex - startIndex);\n  b.used = endIndex;\n  b[b.used++] = 206; // constants.frameEnd;\n\n  var c = new Buffer(b.used);\n  b.copy(c);\n  debug && debug(\"sending frame: \" + c.toJSON());\n  this.write(c);\n\n  this._outboundHeartbeatTimerReset();\n}; // tries to find the next available id slot for a channel\n\n\nConnection.prototype.generateChannelId = function () {\n  // start from the last used slot id\n  var channelId = this.channelCounter;\n\n  while (true) {\n    // use values in range of 1..65535\n    channelId = channelId % channelMax + 1;\n\n    if (!this.channels[channelId]) {\n      break;\n    } // after a full loop throw an Error\n\n\n    if (channelId == this.channelCounter) {\n      throw new Error(\"No valid Channel Id values available\");\n    }\n  }\n\n  this.channelCounter = channelId;\n  return this.channelCounter;\n};","map":{"version":3,"sources":["/Users/alexyang/Desktop/todolist/Traffic-Generator/node_modules/amqp/lib/connection.js"],"names":["net","require","tls","fs","URL","_","debug","EventEmitter","util","serializer","definitions","methods","methodTable","classes","Exchange","Queue","AMQPParser","nodeAMQPVersion","version","maxFrameBuffer","channelMax","defaultPorts","defaultOptions","host","port","login","password","authMechanism","vhost","connectionTimeout","ssl","enabled","defaultSslOptions","rejectUnauthorized","defaultImplOptions","defaultExchangeName","reconnect","reconnectBackoffStrategy","reconnectExponentialLimit","reconnectBackoffTime","defaultClientProperties","platform","process","product","Connection","module","exports","connectionArgs","options","readyCallback","call","setOptions","setImplOptions","_readyCallback","connectionAttemptScheduled","_defaultExchange","channelCounter","_sendBuffer","Buffer","_blocked","_blockedReason","inherits","prototype","urlo","url","_parseURLOptions","sslo","assignIn","clientProperties","implOptions","connect","socket","addAllListeners","_createSocket","_startHandshake","channel","channels","state","end","disconnect","_sendMethod","connectionClose","self","connectEvent","addListener","queues","exchanges","parser","onMethod","method","args","_onMethod","onContent","data","length","_onContent","onContentHeader","classInfo","weight","properties","size","JSON","stringify","name","_onContentHeader","onHeartBeat","emit","onError","e","readyEmitted","execute","exception","_inboundHeartbeatTimerReset","backoffTime","backoff","_inboundHeartbeatTimer","clearTimeout","_outboundHeartbeatTimer","queue","index","consumerTagOptions","setTimeout","removeListener","forEach","_outboundHeartbeatTimerReset","Error","heartbeat","writable","write","exchange","openCallback","undefined","type","generateChannelId","exchangeClosed","callback","arguments","q","queueClosed","publish","routingKey","body","once","_bodyToBuffer","jsonBody","props","contentType","gracePeriod","readable","heartbeatForceReconnect","_saslResponse","response","LOGIN","PASSWORD","_onChannelMethod","connectionStart","versionMajor","versionMinor","serverProperties","connectionStartOk","mechanism","locale","connectionTune","frameMax","setMaxFrameBuffer","connectionTuneOk","connectionOpen","virtualHost","reserved1","reserved2","connectionOpenOk","replyText","code","replyCode","listeners","console","log","destroy","connectionCloseOk","connectionBlocked","reason","connectionUnblocked","connectionString","opts","parse","scheme","protocol","substring","lastIndexOf","hostname","auth","split","pathname","unescape","substr","_chooseHost","Array","isArray","hosti","hostPreference","parseInt","Math","random","hostName","parsedHost","noDelay","resetConnectionTimeout","_getSSLOptions","connTimeout","setNoDelay","events","event","on","bind","apply","sslConnectionOptions","pfxFile","pfx","readFileSync","keyFile","key","certFile","cert","caFile","ca","map","f","passphrase","ciphers","secureProtocol","String","fromCharCode","_sendBody","r","buffer","_sendHeader","pos","len","metaSize","maxBodySize","bodySize","frameSize","b","used","serializeInt","copy","lengthStart","bodyStart","defaults","propertyFlags","i","fields","serializeFields","bodyEnd","s","lengthIndex","startIndex","classIndex","methodIndex","endIndex","c","toJSON","channelId"],"mappings":"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","sourcesContent":["'use strict';\nvar net = require('net');\nvar tls = require('tls');\nvar fs = require('fs');\nvar URL = require('url');\nvar _ = require('lodash');\nvar debug = require('./debug');\nvar EventEmitter = require('events').EventEmitter;\nvar util = require('util');\nvar serializer = require('./serializer');\nvar definitions = require('./definitions');\nvar methods = definitions.methods;\nvar methodTable = definitions.methodTable;\nvar classes = definitions.classes;\nvar Exchange = require('./exchange');\nvar Queue = require('./queue');\nvar AMQPParser = require('./parser');\nvar nodeAMQPVersion = require('../package').version;\n\nvar maxFrameBuffer = 131072; // 128k, same as rabbitmq (which was\n                             // copying qpid)\nvar channelMax = 65535;\nvar defaultPorts = { 'amqp': 5672, 'amqps': 5671 };\n\nvar defaultOptions = {\n  host: 'localhost',\n  port: defaultPorts['amqp'],\n  login: 'guest',\n  password: 'guest',\n  authMechanism: 'AMQPLAIN',\n  vhost: '/',\n  connectionTimeout: 10000,\n  ssl: {\n    enabled: false\n  }\n};\n\nvar defaultSslOptions = {\n  port: defaultPorts['amqps'],\n  ssl: {\n    rejectUnauthorized: true\n  }\n};\n\nvar defaultImplOptions = {\n  defaultExchangeName: '',\n  reconnect: true,\n  reconnectBackoffStrategy: 'linear',\n  reconnectExponentialLimit: 120000,\n  reconnectBackoffTime: 1000\n};\n\nvar defaultClientProperties = {\n  version: nodeAMQPVersion,\n  platform: 'node-' + process.version,\n  product: 'node-amqp'\n};\n\nvar Connection = module.exports = function Connection (connectionArgs, options, readyCallback) {\n  EventEmitter.call(this);\n  this.setOptions(connectionArgs);\n  this.setImplOptions(options);\n\n  if (typeof readyCallback === 'function') {\n    this._readyCallback = readyCallback;\n  }\n\n  this.connectionAttemptScheduled = false;\n  this._defaultExchange = null;\n  this.channelCounter = 0;\n  this._sendBuffer = new Buffer(maxFrameBuffer);\n\n  this._blocked = false;\n  this._blockedReason = null;\n};\nutil.inherits(Connection, EventEmitter);\n\n\n\nConnection.prototype.setOptions = function (options) {\n  var urlo = (options && options.url) ? this._parseURLOptions(options.url) : {};\n  var sslo = (options && options.ssl && options.ssl.enabled) ? defaultSslOptions : {};\n  this.options = _.assignIn({}, defaultOptions, sslo, urlo, options || {});\n  this.options.clientProperties =  _.assignIn({}, defaultClientProperties, (options && options.clientProperties) || {});\n};\n\nConnection.prototype.setImplOptions = function (options) {\n  this.implOptions = _.assignIn({}, defaultImplOptions, options || {});\n};\n\nConnection.prototype.connect = function () {\n  // If this is our first connection, add listeners.\n  if (!this.socket) this.addAllListeners();\n\n  this._createSocket();\n  this._startHandshake();\n};\n\nConnection.prototype.reconnect = function () {\n  // Suspend activity on channels\n  for (var channel in this.channels) {\n    this.channels[channel].state = 'closed';\n  }\n  debug && debug(\"Connection lost, reconnecting...\");\n  // Terminate socket activity\n  if (this.socket) this.socket.end();\n  this.connect();\n};\n\nConnection.prototype.disconnect = function () {\n  debug && debug(\"Sending disconnect request to server\");\n  this._sendMethod(0, methods.connectionClose, {\n    'replyText': 'client disconnect',\n    'replyCode': 200,\n    'classId': 0,\n    'methodId': 0\n  });\n};\n\nConnection.prototype.addAllListeners = function() {\n  var self = this;\n  var connectEvent = this.options.ssl.enabled ? 'secureConnect' : 'connect';\n\n\n  self.addListener(connectEvent, function() {\n    // In the case where this is a reconnection, do not trample on the existing\n    // channels.\n    // For your reference, channel 0 is the control channel.\n    self.channels = self.channels || {0:self};\n    self.queues = self.queues || {};\n    self.exchanges = self.exchanges || {};\n\n    self.parser = new AMQPParser('0-9-1', 'client');\n\n    self.parser.onMethod = function (channel, method, args) {\n      self._onMethod(channel, method, args);\n    };\n\n    self.parser.onContent = function (channel, data) {\n      debug && debug(channel + \" > content \" + data.length);\n      if (self.channels[channel] && self.channels[channel]._onContent) {\n        self.channels[channel]._onContent(channel, data);\n      } else {\n        debug && debug(\"unhandled content: \" + data);\n      }\n    };\n\n    self.parser.onContentHeader = function (channel, classInfo, weight, properties, size) {\n      debug && debug(channel + \" > content header \" + JSON.stringify([classInfo.name, weight, properties, size]));\n      if (self.channels[channel] && self.channels[channel]._onContentHeader) {\n        self.channels[channel]._onContentHeader(channel, classInfo, weight, properties, size);\n      } else {\n        debug && debug(\"unhandled content header\");\n      }\n    };\n\n    self.parser.onHeartBeat = function () {\n      self.emit(\"heartbeat\");\n      debug && debug(\"heartbeat\");\n    };\n\n    self.parser.onError = function (e) {\n      self.emit(\"error\", e);\n      self.emit(\"close\");\n    };\n\n    // Remove readyEmitted flag so we can detect an auth error.\n    self.readyEmitted = false;\n  });\n\n  self.addListener('data', function (data) {\n    if(self.parser != null){\n      try {\n        self.parser.execute(data);\n      } catch (exception) {\n        self.emit('error', exception);\n        return;\n      }\n    }\n    self._inboundHeartbeatTimerReset();\n  });\n\n  var backoffTime = null;\n  self.addListener('error', function backoff(e) {\n    if (self._inboundHeartbeatTimer !== null) {\n      clearTimeout(self._inboundHeartbeatTimer);\n      self._inboundHeartbeatTimer = null;\n    }\n    if (self._outboundHeartbeatTimer !== null) {\n      clearTimeout(self._outboundHeartbeatTimer);\n      self._outboundHeartbeatTimer = null;\n    }\n\n    if (!self.connectionAttemptScheduled) {\n      // Set to true, as we are presently in the process of scheduling one.\n      self.connectionAttemptScheduled = true;\n\n      // Kill the socket, if it hasn't been killed already.\n      self.socket.end();\n\n      // Reset parser state\n      self.parser = null;\n\n      // In order for our reconnection to be seamless, we have to notify the\n      // channels that they are no longer connected so that nobody attempts\n      // to send messages which would be doomed to fail.\n      for (var channel in self.channels) {\n        if (channel !== '0') {\n          self.channels[channel].state = 'closed';\n        }\n      }\n      // Queues are channels (so we have already marked them as closed), but\n      // queues have special needs, since the subscriptions will no longer\n      // be known to the server when we reconnect.  Mark the subscriptions as\n      // closed so that we can resubscribe them once we are reconnected.\n      for (var queue in self.queues) {\n        for (var index in self.queues[queue].consumerTagOptions) {\n          self.queues[queue].consumerTagOptions[index]['state'] = 'closed';\n        }\n      }\n\n      // Begin reconnection attempts\n      if (self.implOptions.reconnect) {\n        // Don't thrash, use a backoff strategy.\n        if (backoffTime === null) {\n          // This is the first time we've failed since a successful connection,\n          // so use the configured backoff time without any modification.\n          backoffTime = self.implOptions.reconnectBackoffTime;\n        } else if (self.implOptions.reconnectBackoffStrategy === 'exponential') {\n          // If you've configured exponential backoff, we'll double the\n          // backoff time each subsequent attempt until success.\n          backoffTime *= 2;\n          // limit the maxium timeout, to avoid potentially unlimited stalls\n          if(backoffTime > self.implOptions.reconnectExponentialLimit){\n            backoffTime = self.implOptions.reconnectExponentialLimit;\n          }\n\n        } else if (self.implOptions.reconnectBackoffStrategy === 'linear') {\n          // Linear strategy is the default.  In this case, we will retry at a\n          // constant interval, so there's no need to change the backoff time\n          // between attempts.\n        } else {\n          // TODO should we warn people if they picked a nonexistent strategy?\n        }\n\n        setTimeout(function () {\n          // Set to false, so that if we fail in the reconnect attempt, we can\n          // schedule another one.\n          self.connectionAttemptScheduled = false;\n          self.reconnect();\n        }, backoffTime);\n      } else {\n        self.removeListener('error', backoff);\n      }\n    }\n  });\n\n  self.addListener('ready', function () {\n    // Reset the backoff time since we have successfully connected.\n    backoffTime = null;\n\n    if (self.implOptions.reconnect) {\n      // Reconnect any channels which were open.\n      _.forEach(self.channels, function(channel, index) {\n        if (index !== '0') channel.reconnect();\n      });\n    }\n\n    // Set 'ready' flag for auth failure detection.\n    this.readyEmitted = true;\n\n    // Restart the heartbeat to the server\n    self._outboundHeartbeatTimerReset();\n  });\n\n  // Apparently, it is not possible to determine if an authentication error\n  // has occurred, but when the connection closes then we can HINT that a\n  // possible authentication error has occured.  Although this may be a bug\n  // in the spec, handling it as a possible error is considerably better than\n  // failing silently.\n  self.addListener('end', function (){\n    if (!this.readyEmitted){\n      this.emit('error', new Error(\n        'Connection ended: possibly due to an authentication failure.'\n      ));\n    }\n  });\n};\n\nConnection.prototype.heartbeat = function () {\n  if(this.socket.writable) this.write(new Buffer([8,0,0,0,0,0,0,206]));\n};\n\n// connection.exchange('my-exchange', { type: 'topic' });\n// Options\n// - type 'fanout', 'direct', or 'topic' (default)\n// - passive (boolean)\n// - durable (boolean)\n// - autoDelete (boolean, default true)\nConnection.prototype.exchange = function (name, options, openCallback) {\n  if (name === undefined) name = this.implOptions.defaultExchangeName;\n\n  if (!options) options = {};\n  if (name !== '' && options.type === undefined) options.type = 'topic';\n\n  try{\n    var channel = this.generateChannelId();\n  }catch(exception){\n    this.emit(\"error\", exception);\n    return;\n  }\n  var exchange = new Exchange(this, channel, name, options, openCallback);\n  this.channels[channel] = exchange;\n  this.exchanges[name] = exchange;\n  return exchange;\n};\n\n// remove an exchange when it's closed (called from Exchange)\nConnection.prototype.exchangeClosed = function (name) {\n  if (this.exchanges[name]) delete this.exchanges[name];\n};\n\n// Options\n// - passive (boolean)\n// - durable (boolean)\n// - exclusive (boolean)\n// - autoDelete (boolean, default true)\nConnection.prototype.queue = function (name /* options, openCallback */) {\n  var options, callback;\n  if (typeof arguments[1] == 'object') {\n    options = arguments[1];\n    callback = arguments[2];\n  } else {\n    callback = arguments[1];\n  }\n\n  try{\n    var channel = this.generateChannelId();\n  }catch(exception){\n    this.emit(\"error\", exception);\n    return;\n  }\n\n  var q = new Queue(this, channel, name, options, callback);\n  this.channels[channel] = q;\n  return q;\n};\n\n// remove a queue when it's closed (called from Queue)\nConnection.prototype.queueClosed = function (name) {\n  if (this.queues[name]) delete this.queues[name];\n};\n\n// Publishes a message to the default exchange.\nConnection.prototype.publish = function (routingKey, body, options, callback) {\n  if (!this._defaultExchange) {\n    this._defaultExchange = this.exchange();\n  }\n\n  var exchange = this._defaultExchange;\n  if (exchange.state === 'open') {\n    exchange.publish(routingKey, body, options, callback);\n  } else {\n    exchange.once('open', function() {\n      exchange.publish(routingKey, body, options, callback);\n    });\n  }\n};\n\nConnection.prototype._bodyToBuffer = function (body) {\n  // Handles 3 cases\n  // - body is utf8 string\n  // - body is instance of Buffer\n  // - body is an object and its JSON representation is sent\n  // Does not handle the case for streaming bodies.\n  // Returns buffer.\n  if (typeof(body) == 'string') {\n    return [null, new Buffer(body, 'utf8')];\n  } else if (body instanceof Buffer) {\n    return [null, body];\n  } else {\n    var jsonBody = JSON.stringify(body);\n\n    debug && debug('sending json: ' + jsonBody);\n\n    var props = {contentType: 'application/json'};\n    return [props, new Buffer(jsonBody, 'utf8')];\n  }\n};\n\nConnection.prototype._inboundHeartbeatTimerReset = function () {\n  if (this._inboundHeartbeatTimer !== null) {\n    clearTimeout(this._inboundHeartbeatTimer);\n    this._inboundHeartbeatTimer = null;\n  }\n  if (this.options.heartbeat) {\n    var self = this;\n    var gracePeriod = 2 * this.options.heartbeat;\n    this._inboundHeartbeatTimer = setTimeout(function () {\n      if(self.socket.readable || self.options.heartbeatForceReconnect){\n        self.emit('error', new Error('no heartbeat or data in last ' + gracePeriod + ' seconds'));\n      }\n    }, gracePeriod * 1000);\n  }\n};\n\nConnection.prototype._outboundHeartbeatTimerReset = function () {\n  if (this._outboundHeartbeatTimer !== null) {\n    clearTimeout(this._outboundHeartbeatTimer);\n    this._outboundHeartbeatTimer = null;\n  }\n  if (this.socket.writable && this.options.heartbeat) {\n    var self = this;\n    this._outboundHeartbeatTimer = setTimeout(function () {\n      self.heartbeat();\n      self._outboundHeartbeatTimerReset();\n    }, 1000 * this.options.heartbeat);\n  }\n};\n\nConnection.prototype._saslResponse = function () {\n  var response;\n  if (this.options.authMechanism == 'AMQPLAIN')\n    response = {\n      LOGIN: this.options.login,\n      PASSWORD: this.options.password\n    };\n  else if (this.options.authMechanism == 'PLAIN')\n    response = \"\\0\" + this.options.login + \"\\0\" + this.options.password;\n  else if (this.options.authMechanism == 'EXTERNAL')\n    response = \"\\0\";\n  else if (this.options.authMechanism == 'ANONYMOUS')\n    response = \"\\0\";\n  else\n    response = this.options.response;\n\n  return response;\n}\n\nConnection.prototype._onMethod = function (channel, method, args) {\n  debug && debug(channel + \" > \" + method.name + \" \" + JSON.stringify(args));\n\n  // Channel 0 is the control channel. If not zero then delegate to\n  // one of the channel objects.\n\n  if (channel > 0) {\n    if (!this.channels[channel]) {\n      debug && debug(\"Received message on untracked channel.\");\n      return;\n    }\n    if (!this.channels[channel]._onChannelMethod) {\n      throw new Error('Channel ' + channel + ' has no _onChannelMethod method.');\n    }\n    this.channels[channel]._onChannelMethod(channel, method, args);\n    return;\n  }\n\n  // channel 0\n\n  switch (method) {\n    // 2. The server responds, after the version string, with the\n    // 'connectionStart' method (contains various useless information)\n    case methods.connectionStart:\n      // We check that they're serving us AMQP 0-9\n      if (args.versionMajor !== 0 && args.versionMinor != 9) {\n        this.socket.end();\n        this.emit('error', new Error(\"Bad server version\"));\n        return;\n      }\n      this.serverProperties = args.serverProperties;\n      // 3. Then we reply with StartOk, containing our useless information.\n      this._sendMethod(0, methods.connectionStartOk, {\n        clientProperties: this.options.clientProperties,\n        mechanism: this.options.authMechanism,\n        response: this._saslResponse(),\n        locale: 'en_US'\n      });\n      break;\n\n    // 4. The server responds with a connectionTune request\n    case methods.connectionTune:\n      if (args.frameMax) {\n          debug && debug(\"tweaking maxFrameBuffer to \" + args.frameMax);\n          maxFrameBuffer = args.frameMax;\n          this._sendBuffer = new Buffer(maxFrameBuffer);\n          this.parser.setMaxFrameBuffer(maxFrameBuffer);\n      }\n      if (args.channelMax) {\n          debug && debug(\"tweaking channelMax to \" + args.channelMax);\n          channelMax = args.channelMax;\n      }\n      // 5. We respond with connectionTuneOk\n      this._sendMethod(0, methods.connectionTuneOk, {\n        channelMax: channelMax,\n        frameMax: maxFrameBuffer,\n        heartbeat: this.options.heartbeat || 0\n      });\n      // 6. Then we have to send a connectionOpen request\n      this._sendMethod(0, methods.connectionOpen, {\n        virtualHost: this.options.vhost\n        // , capabilities: ''\n        // , insist: true\n        ,\n        reserved1: '',\n        reserved2: true\n      });\n      break;\n\n\n    case methods.connectionOpenOk:\n      // 7. Finally they respond with connectionOpenOk\n      // Whew! That's why they call it the Advanced MQP.\n      if (this._readyCallback) {\n        this._readyCallback(this);\n        this._readyCallback = null;\n      }\n      this.emit('ready');\n      break;\n\n    case methods.connectionClose:\n      var e = new Error(args.replyText);\n      e.code = args.replyCode;\n      if (!this.listeners('close').length) {\n        console.log('Unhandled connection error: ' + args.replyText);\n      }\n      this.socket.destroy(e);\n      break;\n\n    case methods.connectionCloseOk:\n      debug && debug(\"Received close-ok from server, closing socket\");\n      this.socket.end();\n      this.socket.destroy();\n      break;\n\n    case methods.connectionBlocked:\n      debug && debug('Received connection.blocked from server with reason: ' + args.reason);\n      this._blocked = true;\n      this._blockedReason = args.reason;\n      this.emit('blocked');\n      break;\n\n    case methods.connectionUnblocked:\n      debug && debug('Received connection.unblocked from server');\n      this._blocked = false;\n      this._blockedReason = null;\n      this.emit('unblocked');\n      break;\n\n    default:\n      throw new Error(\"Uncaught method '\" + method.name + \"' with args \" +\n          JSON.stringify(args));\n  }\n};\n\n// Generate connection options from URI string formatted with amqp scheme.\nConnection.prototype._parseURLOptions = function(connectionString) {\n  var opts = {};\n  opts.ssl = {};\n  var url = URL.parse(connectionString);\n  var scheme = url.protocol.substring(0, url.protocol.lastIndexOf(':'));\n  if (scheme != 'amqp' && scheme != 'amqps') {\n    throw new Error('Connection URI must use amqp or amqps scheme. ' +\n                    'For example, \"amqp://bus.megacorp.internal:5766\".');\n  }\n  opts.ssl.enabled = ('amqps' === scheme);\n  opts.host = url.hostname;\n  opts.port = url.port || defaultPorts[scheme];\n  if (url.auth) {\n    var auth = url.auth.split(':');\n    auth[0] && (opts.login = auth[0]);\n    auth[1] && (opts.password = auth[1]);\n  }\n  if (url.pathname) {\n    opts.vhost = unescape(url.pathname.substr(1));\n  }\n  return opts;\n};\n\n/*\n *\n * Connect helpers\n *\n */\n\n// If you pass a array of hosts, lets choose a random host or the preferred host number, or then next one.\nConnection.prototype._chooseHost = function() {\n  if(Array.isArray(this.options.host)){\n    if(this.hosti == null){\n      if(typeof this.options.hostPreference == 'number') {\n        this.hosti = (this.options.hostPreference < this.options.host.length) ?\n          this.options.hostPreference : this.options.host.length-1;\n      } else {\n        this.hosti = parseInt(Math.random() * this.options.host.length, 10);\n      }\n    } else {\n      // If this is already set, it looks like we want to choose another one.\n      // Add one to hosti but don't overflow it.\n      this.hosti = (this.hosti + 1) % this.options.host.length;\n    }\n    return this.options.host[this.hosti];\n  } else {\n    return this.options.host;\n  }\n};\n\nConnection.prototype._createSocket = function() {\n  var hostName = this._chooseHost(), self = this, port = this.options.port;\n  var parsedHost = URL.parse(hostName);\n  if(parsedHost.port){\n    hostName = parsedHost.hostname;\n    port = parsedHost.port;\n  }\n\n  var options = {\n    port: port,\n    host: hostName\n  };\n\n  // Disable tcp nagle's algo\n  // Default: true, makes small messages faster\n  var noDelay = this.options.noDelay || true;\n\n  var resetConnectionTimeout = function () {\n    debug && debug('connected so resetting connection timeout');\n    this.setTimeout(0);\n  };\n\n  // Connect socket\n  if (this.options.ssl.enabled) {\n    debug && debug('making ssl connection');\n    options = _.assignIn(options, this._getSSLOptions());\n    this.socket = tls.connect(options, resetConnectionTimeout);\n  } else {\n    debug && debug('making non-ssl connection');\n    this.socket = net.connect(options, resetConnectionTimeout);\n  }\n  var connTimeout = this.options.connectionTimeout;\n  if (connTimeout) {\n    debug && debug('setting connection timeout to ' + connTimeout);\n    this.socket.setTimeout(connTimeout, function () {\n      debug && debug('connection timeout');\n      this.destroy();\n      var e = new Error('connection timeout');\n      e.name = 'TimeoutError';\n      self.emit('error', e);\n    });\n  }\n\n  this.socket.setNoDelay(noDelay);\n\n  // Proxy events.\n  // Note that if we don't attach a 'data' event, no data will flow.\n  var events = ['close', 'connect', 'data', 'drain', 'error', 'end', 'secureConnect', 'timeout'];\n  _.forEach(events, function(event){\n    self.socket.on(event, self.emit.bind(self, event));\n  });\n\n  // Proxy a few methods that we use / previously used.\n  var methods = ['destroy', 'write', 'pause', 'resume', 'setEncoding', 'ref', 'unref', 'address'];\n  _.forEach(methods, function(method){\n    self[method] = function(){\n      self.socket[method].apply(self.socket, arguments);\n    };\n  });\n};\n\nConnection.prototype.end = function() {\n  if (this.socket) {\n    this.socket.end();\n  }\n\n  this.options.heartbeat = false;\n\n  if (this._inboundHeartbeatTimer !== null) {\n    clearTimeout(this._inboundHeartbeatTimer);\n    this._inboundHeartbeatTimer = null;\n  }\n\n  if (this._outboundHeartbeatTimer !== null) {\n    clearTimeout(this._outboundHeartbeatTimer);\n    this._outboundHeartbeatTimer = null;\n  }\n};\n\nConnection.prototype._getSSLOptions = function() {\n  if (this.sslConnectionOptions) return this.sslConnectionOptions;\n  this.sslConnectionOptions = {};\n\n  if (this.options.ssl.pfxFile) {\n    this.sslConnectionOptions.pfx = fs.readFileSync(this.options.ssl.pfxFile);\n  }\n  if (this.options.ssl.keyFile) {\n    this.sslConnectionOptions.key = fs.readFileSync(this.options.ssl.keyFile);\n  }\n  if (this.options.ssl.certFile) {\n    this.sslConnectionOptions.cert = fs.readFileSync(this.options.ssl.certFile);\n  }\n  if (this.options.ssl.caFile) {\n    if (Array.isArray(this.options.ssl.caFile)) {\n      this.sslConnectionOptions.ca = this.options.ssl.caFile.map(function(f){\n        return fs.readFileSync(f);\n      });\n    } else {\n      this.sslConnectionOptions.ca = fs.readFileSync(this.options.ssl.caFile);\n    }\n  }\n\n  this.sslConnectionOptions.rejectUnauthorized = this.options.ssl.rejectUnauthorized;\n  this.sslConnectionOptions.passphrase = this.options.ssl.passphrase;\n\n  if (this.options.ssl.ciphers) {\n    this.sslConnectionOptions.ciphers = this.options.ssl.ciphers;\n  }\n  if (this.options.ssl.secureProtocol) {\n    this.sslConnectionOptions.secureProtocol = this.options.ssl.secureProtocol;\n  }\n\n  return this.sslConnectionOptions;\n};\n\n// Time to start the AMQP 7-way connection initialization handshake!\n// 1. The client sends the server a version string\nConnection.prototype._startHandshake = function() {\n  debug && debug(\"Initiating handshake...\");\n  this.write(\"AMQP\" + String.fromCharCode(0,0,9,1));\n};\n\n/*\n *\n * Parse helpers\n *\n */\n\nConnection.prototype._sendBody = function (channel, body, properties) {\n  var r = this._bodyToBuffer(body);\n  var props = r[0], buffer = r[1];\n\n  properties = _.assignIn(props || {}, properties);\n\n  this._sendHeader(channel, buffer.length, properties);\n\n  var pos = 0, len = buffer.length;\n  var metaSize = 8; // headerBytes = 7, frameEndBytes = 1\n  var maxBodySize = maxFrameBuffer - metaSize;\n\n  while (len > 0) {\n    var bodySize = len < maxBodySize ? len : maxBodySize;\n    var frameSize = bodySize + metaSize;\n\n    var b = new Buffer(frameSize);\n    b.used = 0;\n    b[b.used++] = 3; // constants.frameBody\n    serializer.serializeInt(b, 2, channel);\n    serializer.serializeInt(b, 4, bodySize);\n    buffer.copy(b, b.used, pos, pos+bodySize);\n    b.used += bodySize;\n    b[b.used++] = 206; // constants.frameEnd;\n    this.write(b);\n\n    len -= bodySize;\n    pos += bodySize;\n  }\n  return;\n};\n\n// connection: the connection\n// channel: the channel to send this on\n// size: size in bytes of the following message\n// properties: an object containing any of the following:\n// - contentType (default 'application/octet-stream')\n// - contentEncoding\n// - headers\n// - deliveryMode\n// - priority (0-9)\n// - correlationId\n// - replyTo\n// - expiration\n// - messageId\n// - timestamp\n// - userId\n// - appId\n// - clusterId\nConnection.prototype._sendHeader = function(channel, size, properties) {\n  var b = new Buffer(maxFrameBuffer); // FIXME allocating too much.\n                                      // use freelist?\n  b.used = 0;\n\n  var classInfo = classes[60]; // always basic class.\n\n  // 7 OCTET FRAME HEADER\n\n  b[b.used++] = 2; // constants.frameHeader\n\n  serializer.serializeInt(b, 2, channel);\n\n  var lengthStart = b.used;\n\n  serializer.serializeInt(b, 4, 0 /*dummy*/); // length\n\n  var bodyStart = b.used;\n\n  // HEADER'S BODY\n\n  serializer.serializeInt(b, 2, classInfo.index);   // class 60 for Basic\n  serializer.serializeInt(b, 2, 0);                 // weight, always 0 for rabbitmq\n  serializer.serializeInt(b, 8, size);              // byte size of body\n\n  // properties - first propertyFlags\n  properties = _.defaults(properties || {}, {contentType: 'application/octet-stream'});\n  var propertyFlags = 0;\n  for (var i = 0; i < classInfo.fields.length; i++) {\n    if (properties[classInfo.fields[i].name]) propertyFlags |= 1 << (15-i);\n  }\n  serializer.serializeInt(b, 2, propertyFlags);\n  // now the actual properties.\n  serializer.serializeFields(b, classInfo.fields, properties, false);\n\n  //serializeTable(b, properties);\n\n  var bodyEnd = b.used;\n\n  // Go back to the header and write in the length now that we know it.\n  b.used = lengthStart;\n  serializer.serializeInt(b, 4, bodyEnd - bodyStart);\n  b.used = bodyEnd;\n\n  // 1 OCTET END\n\n  b[b.used++] = 206; // constants.frameEnd;\n\n  var s = new Buffer(b.used);\n  b.copy(s);\n\n  //debug && debug('header sent: ' + JSON.stringify(s));\n\n  this.write(s);\n};\n\nConnection.prototype._sendMethod = function (channel, method, args) {\n  debug && debug(channel + \" < \" + method.name + \" \" + JSON.stringify(args));\n  var b = this._sendBuffer;\n  b.used = 0;\n\n  b[b.used++] = 1; // constants.frameMethod\n\n  serializer.serializeInt(b, 2, channel);\n\n  var lengthIndex = b.used;\n\n  serializer.serializeInt(b, 4, 42); // replace with actual length.\n\n  var startIndex = b.used;\n\n\n  serializer.serializeInt(b, 2, method.classIndex); // short, classId\n  serializer.serializeInt(b, 2, method.methodIndex); // short, methodId\n\n  serializer.serializeFields(b, method.fields, args, true);\n\n  var endIndex = b.used;\n\n  // write in the frame length now that we know it.\n  b.used = lengthIndex;\n  serializer.serializeInt(b, 4, endIndex - startIndex);\n  b.used = endIndex;\n\n  b[b.used++] = 206; // constants.frameEnd;\n\n  var c = new Buffer(b.used);\n  b.copy(c);\n\n  debug && debug(\"sending frame: \" + c.toJSON());\n\n  this.write(c);\n\n  this._outboundHeartbeatTimerReset();\n};\n\n// tries to find the next available id slot for a channel\nConnection.prototype.generateChannelId = function () {\n  // start from the last used slot id\n  var channelId = this.channelCounter;\n  while(true){\n    // use values in range of 1..65535\n    channelId = channelId % channelMax + 1;\n    if(!this.channels[channelId]){\n      break;\n    }\n    // after a full loop throw an Error\n    if(channelId == this.channelCounter){\n      throw new Error(\"No valid Channel Id values available\");\n    }\n  }\n  this.channelCounter = channelId;\n  return this.channelCounter;\n};\n"]},"metadata":{},"sourceType":"script"}